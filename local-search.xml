<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>研究-日报</title>
    <link href="/2021/10/30/%E7%A0%94%E7%A9%B6-%E6%97%A5%E6%8A%A5/"/>
    <url>/2021/10/30/%E7%A0%94%E7%A9%B6-%E6%97%A5%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<h6 id="2021年8月30日【日报】"><a href="#2021年8月30日【日报】" class="headerlink" title="2021年8月30日【日报】"></a>2021年8月30日【日报】</h6><p>今天的时间找了一下之前阅读的论文，总结了无人机自身约束：最大航程、最小飞行距离、飞行速度和最大转弯角，在多无人机时要考虑时间协同约束以及空间约束，主要考虑两个指标：总的无人机航迹长度、整体完成任务的时间。</p><h6 id="2021年8月31日【日报】"><a href="#2021年8月31日【日报】" class="headerlink" title="2021年8月31日【日报】"></a>2021年8月31日【日报】</h6><p>今天找了几篇论文，主要是多无人机协同方面的。其中一篇提到了Airlearning，主要的以Airsim为基础，使用深度学习、强化学习等知识，对无人机获得的信息进行融合，论文还没看完。</p><h6 id="2021年9月1日【日报】"><a href="#2021年9月1日【日报】" class="headerlink" title="2021年9月1日【日报】"></a>2021年9月1日【日报】</h6><p>今天的时间看之前的论文，剩下的时间主要大致读了一下苏鑫师姐的论文和给出的审稿意见，思考如何进行修改。</p><h6 id="2021年9月2日【日报】"><a href="#2021年9月2日【日报】" class="headerlink" title="2021年9月2日【日报】"></a>2021年9月2日【日报】</h6><p>今天看了一部分师姐的论文，其中第一条意见需要在引言部分进行修改，需要读一些无人机配送领域近年的文献。</p><h6 id="2021年9月3日【日报】"><a href="#2021年9月3日【日报】" class="headerlink" title="2021年9月3日【日报】"></a>2021年9月3日【日报】</h6><p>今天引言中加入了几个相关的参考文献，关于审稿人给出的第2条意见，建议增加‘问题描述和模型构建’的补充解释，现在正在阅读师姐的大论文。</p><h6 id="2021年9月6日【日报】"><a href="#2021年9月6日【日报】" class="headerlink" title="2021年9月6日【日报】"></a>2021年9月6日【日报】</h6><p>今天阅读论文，论文中提出来一种基于任务碎片化重组的多无人机能耗公平性算法，先通过聚类算法对任务区域内的目标进行分簇，然后通过改进的遗传算法找到簇内的最小能量消耗。其中能量消耗考虑了路径长度以及悬停能量消耗，应用场景是无人机实现“数据摆渡（Data Ferry）”,即无人机在任务区域内采集信息，然后将信息传递给数据中心。</p><h6 id="2021年9月7日【日报】"><a href="#2021年9月7日【日报】" class="headerlink" title="2021年9月7日【日报】"></a>2021年9月7日【日报】</h6><p>阅读论文，这篇论文解决任务分配问题与航迹规划分开，无人机实际的飞行会影响任务分配的结果，导致任务分配的方案不是最佳方案，同时提出了异构目标不同的侦查方式。</p><h6 id="2021年9月8日【日报】"><a href="#2021年9月8日【日报】" class="headerlink" title="2021年9月8日【日报】"></a>2021年9月8日【日报】</h6><p>今天主要考虑无人机的能耗如何放入到优化中，现有的论文参考为：飞行能耗=α*L,其中α是单位距离的能量消耗率，L为无人机的飞行距离；悬停能耗与收集数据时的信息传输速率、节点的数据量相关。这个方面大多数认为每个节点的数据量是相同的，研究中可以考虑数据量不同的解决方案。</p><h6 id="2021年9月9日【日报】"><a href="#2021年9月9日【日报】" class="headerlink" title="2021年9月9日【日报】"></a>2021年9月9日【日报】</h6><p>今天在查找无人机安全通信的研究现状时，找到了关于无人机任务分配的论文，从通信的角度完成任务分配。国内外未来趋势还需要再找找资料。</p><h6 id="2021年9月10日【日报】"><a href="#2021年9月10日【日报】" class="headerlink" title="2021年9月10日【日报】"></a>2021年9月10日【日报】</h6><p>今天主要在阅读论文，找了几篇关于CRLB理论方面的论文，并且在数学方面深入了解了这个理论，对下一步的研究有帮助。</p><h6 id="2021年9月11日【日报】"><a href="#2021年9月11日【日报】" class="headerlink" title="2021年9月11日【日报】"></a>2021年9月11日【日报】</h6><p>今天查阅论文，其中设计了一种综合考虑飞行航程、任务收益以及任务完成时间窗口的混合粒子群任务分配算法，主要针对新目标等实时事件导致的初始分配计划失效问题，这个问题也是任务分配中需要考虑的。</p><p>【周报】本周主要在阅读论文，针对的都是多无人机任务分配的内容。现在通过阅读论文，发现现有研究的存在的问题：</p><ol><li>   任务分配时没有考虑无人机飞行的真实轨迹，导致执行过程中无人机的飞行轨迹较大；</li><li>   现有的任务类型基本上是一致的，并没有考虑无人机执行不同任务的时间、能量消耗；</li><li>   实时事件的影响，没有考虑任务执行中不确定因素的影响。</li></ol><p>接下来的研究工作主要是针对上述问题进行解决，另外把之前Air-learning 的代码进行了学习，希望在后续中能够用得到。</p><h6 id="2021年9月13日【日报】"><a href="#2021年9月13日【日报】" class="headerlink" title="2021年9月13日【日报】"></a>2021年9月13日【日报】</h6><p>今天主要在阅读论文，《Decentralized Multi-UAV Flight Autonomy for Moving Convoys Search and Track 》，这篇论文通过固定翼无人机群组。实现对地面车队的跟踪，主要用到的方法是基于有限状态机的控制逻辑设计方法，值得借鉴的地方是：将无人机执行任务分为了几种模式：起飞、飞到任务区域、搜索和跟踪模式。</p><h6 id="2021年9月14日【日报】"><a href="#2021年9月14日【日报】" class="headerlink" title="2021年9月14日【日报】"></a>2021年9月14日【日报】</h6><p>今天把昨天的论文读完了，对细节部分进行了补充。剩下的时间在github上找代码，其中有一个作为任务分配的baseline，里面使用的方法是蚁群、PSO等算法，有一些性能曲线，应该会在对比方面有帮助。</p><h6 id="2021年9月15日【日报】"><a href="#2021年9月15日【日报】" class="headerlink" title="2021年9月15日【日报】"></a>2021年9月15日【日报】</h6><p>今天找了一篇综述文章，现有的多无人机协同根据任务对象的不同分为“点对点”、“点对面”，第一种主要解决方案有数学规划法、协商法、群智能算法。下表是方法的优缺点以及改进的方案，现在主要思考将群智能算法与强化学习结合，将无人机的低能耗、路径短以及整个系统执行任务的时间作为导向，并在其中加入数学规划的思想</p><h6 id="2021年9月16日【日报】"><a href="#2021年9月16日【日报】" class="headerlink" title="2021年9月16日【日报】"></a>2021年9月16日【日报】</h6><p>今天主要看昨天论文中“点对面”侦查方式，要求无人机在一定的约束条件下能能够对搜索区域进行覆盖侦查，多无人机能够提升其覆盖效率和可靠性。主要分为已知环境和未知环境两种方式，其中主要为区域分割方式、最佳覆盖路线的确定等。</p><h6 id="2021年9月17日【日报】"><a href="#2021年9月17日【日报】" class="headerlink" title="2021年9月17日【日报】"></a>2021年9月17日【日报】</h6><p>今天主要在看论文，提出了一种搜索与动态控制框架，在环境中提升无人机搜索和扑灭目标的效率，任务场景是无人机执行森林中的火灾抢救，其中得到的实验结果无人机能够根据火灾的情况进行收敛。</p><h6 id="2021年9月18日【日报】"><a href="#2021年9月18日【日报】" class="headerlink" title="2021年9月18日【日报】"></a>2021年9月18日【日报】</h6><p>今天的时间主要在查找论文，主要集中在无人机任务动态分配方面，找到了几篇近几年的论文，也有使用强化学习方法。剩下的时间在配置代码的环境。<br>【周报】本周的主要内容就是读论文，找研究的点，整理现有的几种研究方法。针对多无人机动态分配任务方面还需要有一定的文献积累。下周准备大量阅读论文，尽快确定研究方法。</p><h6 id="2021年9月22日【日报】"><a href="#2021年9月22日【日报】" class="headerlink" title="2021年9月22日【日报】"></a>2021年9月22日【日报】</h6><p>今天主要在查找论文，其中用到的主要的方法是通过自组织神经网络完成初始的任务分配，但是现有研究的不足是没有在算法中考虑无人机飞行的环境信息，仅仅是单纯的任务分配。强化学习方法本质上是优化的算法，在思考应该怎么将其加入其中。</p><h6 id="2021年9月23日【日报】"><a href="#2021年9月23日【日报】" class="headerlink" title="2021年9月23日【日报】"></a>2021年9月23日【日报】</h6><p>今天主要在找关于SOM的知识，它主要有两层神经网络，仅包含输入层与输出层，现在主要用来解决聚类和降维问题。从github中找到了其解决多旅行商问题的代码，现在还比较简陋，明天准备看其中具体的代码。</p><h6 id="2021年9月24日【日报】"><a href="#2021年9月24日【日报】" class="headerlink" title="2021年9月24日【日报】"></a>2021年9月24日【日报】</h6><p>今天主要看昨天下载的代码，主要看其中的竞争学习的部分，原理是一个神经元兴奋后，会对周围的神经元产生抑制作用，依靠神经元之间相互竞争逐渐优化网络，完成最终的任务。<br>【周报】本周主要通过阅读论文，大致上确定了研究的问题点，学习了SOM神经网络方面的知识。下周主要看其中的代码，阅读论文并总结任务分配中需要的约束条件。</p><h6 id="2021年9月26日【日报】"><a href="#2021年9月26日【日报】" class="headerlink" title="2021年9月26日【日报】"></a>2021年9月26日【日报】</h6><p>今天的内容是看论文和写代码，主要对SOM的原理更加了解；找了一个英文论文，主要是通过SOM实现自主路径规划，了解了SOM在其中的函数输入和竞争机制。</p><h6 id="2021年9月27日【日报】"><a href="#2021年9月27日【日报】" class="headerlink" title="2021年9月27日【日报】"></a>2021年9月27日【日报】</h6><p>今天主要是看代码，对其中的几个函数进行调试，弄懂主要是干什么的。剩下的时间阅读昨天的论文，对其中模型的创建进行阅读。</p><h6 id="2021年9月28日【日报】"><a href="#2021年9月28日【日报】" class="headerlink" title="2021年9月28日【日报】"></a>2021年9月28日【日报】</h6><p>今天主要是阅读论文，找了以前今年发表的论文，通过SOM算法解决任务分配的问题，只是简单的应用，主要看了网络中获胜神经元是如何产生的，邻域函数等方面的内容，其中还了解了使用三阶分段贝塞尔对路线进行平滑处理的内容。</p><h6 id="2021年9月29日【日报】"><a href="#2021年9月29日【日报】" class="headerlink" title="2021年9月29日【日报】"></a>2021年9月29日【日报】</h6><p>今天找了一篇2021年发表的论文，主要解决火灾救援中的动态任务分配问题，里面建立的模型比较多，单个与多个着火点，同时结合agent的执行效率等因素，通过公式计算火情是否消灭的，感觉对动态任务分配方面有帮助。</p><h6 id="2021年9月30日【日报】"><a href="#2021年9月30日【日报】" class="headerlink" title="2021年9月30日【日报】"></a>2021年9月30日【日报】</h6><p>今天开会后剩下的时间主要在阅读分享时的论文，把还没看完的公式往下看，找了论文中引用的参考文献，追踪了其中的模型，主要是火灾中具体的模型。</p><h6 id="2021年10月5日【日报】"><a href="#2021年10月5日【日报】" class="headerlink" title="2021年10月5日【日报】"></a>2021年10月5日【日报】</h6><p>今天的主要对论文中的公式进行推导，同时追踪到火点在野外环境蔓延的模型，考虑到风、坡度等细节的因素，数学公式很多。剩下的时间看在自动化学报上发表的关于深度强化学习解决组合优化问题的综述文章。</p><h6 id="2021年10月6日【日报】"><a href="#2021年10月6日【日报】" class="headerlink" title="2021年10月6日【日报】"></a>2021年10月6日【日报】</h6><p>今天继续阅读昨天的论文，同时在论文中看到了注意力机制的内容（Attention），该方法现在主要应用于图像处理和NLP领域，主要思想是从复杂的信息中找出对当前信息重要的部分，能够从大量的信息筛选出有价值信息。这种思想与无人机执行紧急出现的任务类似，从多种约束条件中找到几个无人机去执行新的任务。目前正在看这方面的代码。</p><h6 id="2021年10月8日【日报】"><a href="#2021年10月8日【日报】" class="headerlink" title="2021年10月8日【日报】"></a>2021年10月8日【日报】</h6><p>今天的时间主要从encoder-decoder框架的角度深入看注意力机制的内容。思考在无人机任务重分配方面，输入的向量为任务点属性、UAV的位置、性能、当前任务的完成度等内容，找出几个与任务匹配度高的UAV。</p><h6 id="2021年10月9日【日报】"><a href="#2021年10月9日【日报】" class="headerlink" title="2021年10月9日【日报】"></a>2021年10月9日【日报】</h6><p>今天把之前SOM网络的内容深入看了一部分内容，主要是获胜的神经元是如何选择出来的，如何通过公式进行权值的调整，看了一部分这方面MATLAB的代码.<br>【周报】本周主要是深入理解了attention机制、SOM神经网络方面的原理和代码，对野外火灾蔓延的模型中能够的数学公式进行了了解。</p><h6 id="2021年10月11日【日报】"><a href="#2021年10月11日【日报】" class="headerlink" title="2021年10月11日【日报】"></a>2021年10月11日【日报】</h6><p>今天主要考虑注意力机制中query中的向量怎么与无人机执行紧急任务联系在一起，现在考虑的方面有能量消耗率，无人机到达紧急任务点的飞行距离，当前任务的完成度等，正在考虑怎么在代码中实现。</p><h6 id="2021年10月12日【日报】"><a href="#2021年10月12日【日报】" class="headerlink" title="2021年10月12日【日报】"></a>2021年10月12日【日报】</h6><p>今天的时间主要看别人的代码，进行注释、理解、尝试加入自己的内容，剩下的时间主要在查找注意力机制应用在无人机任务分配方面的论文。</p><h6 id="2021年10月13日【日报】"><a href="#2021年10月13日【日报】" class="headerlink" title="2021年10月13日【日报】"></a>2021年10月13日【日报】</h6><p>今天主要看代码、写代码，一方面是SOM实现初始任务分配，一种的方法是对任务点之间的欧几里得距离进行分类，另一种使用角度的方式进行分类，目前采用得是距离的进行分类，实现初始任务的分类，正在改进这方面的代码。</p><h6 id="2021年10月14日【日报】"><a href="#2021年10月14日【日报】" class="headerlink" title="2021年10月14日【日报】"></a>2021年10月14日【日报】</h6><p>今天继续昨天的工作，对原有的代码进行了改进，目前思考怎么将无人机的任务分配场景给呈现出来，正在查阅相关的文档。</p><h6 id="2021年10月16日【日报】"><a href="#2021年10月16日【日报】" class="headerlink" title="2021年10月16日【日报】"></a>2021年10月16日【日报】</h6><p>今天的时间在代码，在任务分配的过程中考虑任务点之间的关联程度，两个任务点越近，关联程度越大，倾向于由一个无人机执行并完成任务。剩下的时间阅读使用SOM解决水下无人机路径规划的论文，在SOM权重更新方面有所借鉴。<br>【周报】本周的时间主要从代码层面理解attention 机制和SOM神经网络，对代码中的输入、输出参数从任务重分配的角度出发改进。</p><h6 id="2021年10月18日【日报】"><a href="#2021年10月18日【日报】" class="headerlink" title="2021年10月18日【日报】"></a>2021年10月18日【日报】</h6><p>今天的时间主要查找使用python的模块matplotlib绘制三维图，考虑到任务基本上都是在地面，使用python中的circle类在x和y轴显示表示任务点，目前可以调整任务点的颜色、位置等属性。</p><h6 id="2021年10月19日【日报】"><a href="#2021年10月19日【日报】" class="headerlink" title="2021年10月19日【日报】"></a>2021年10月19日【日报】</h6><p>今天的时间主要在绘制三维空间下任务分配生成的路径图，现在已经基本完成，还差一些细节的部分需要补充，另外查看SOM源码希望把任务分配后的数据导出来进行显示，这部分的工作还未做完。</p><h6 id="2021年10月20日【日报】"><a href="#2021年10月20日【日报】" class="headerlink" title="2021年10月20日【日报】"></a>2021年10月20日【日报】</h6><p>今天的主要使查阅资料解决现有的问题，虽然还没解决，但是对训练过程中生成数据的形势进一步了解了，剩下时间继续对现有代码进行改进。</p><h6 id="2021年10月22日【日报】"><a href="#2021年10月22日【日报】" class="headerlink" title="2021年10月22日【日报】"></a>2021年10月22日【日报】</h6><p>今天在审稿论文中追踪了几篇与我相关的论文，有一篇是对传统的合同网进行改进，加入了筛选机制和信任机制，解决传统合同网的任务激增、实时性下降的问题，提高动态出现任务的时效性。信任机制可以根据UAV 完成任务的信息确定，同时可减少符合无人机的数量，筛选是根据几种信息对中标的无人机进行排序，最终增加任务完成的效率。在文章中，投标者向量为：</p><p>分别代表UAV编号、需要执行的任务编号、任务的信息（位置）、UAV当前执行的任务序列、竞拍价格。这篇论文体及的部分内容对动态任务分配的内容有帮助。 </p><h6 id="2021年10月23日【日报】"><a href="#2021年10月23日【日报】" class="headerlink" title="2021年10月23日【日报】"></a>2021年10月23日【日报】</h6><p>今天的时间阅读论文，是深圳大学的一名博士生发表在一区上的一篇论文，主要内容是通过生物启发算法解决三维动态环境下无人机集群动态任务分配的问题，贡献是考虑了三维空间环境、对SOM神经网络参数的调整进行了改进、使用贝塞尔曲线对路径进行优化。这篇论文发表的时间较早（2013），应该是较早对无人机任务分配问题进行研究的论文，可通过追踪文献作为对比算法的一种，目前还未完全读完。<br>【周报】本周的时间主要是写代码，创建自己简单的环境，存在一些小问题，并进行了改进；另外阅读了关于任务分配的期刊文章，对思路的整体设计有了启发。</p><h6 id="2021年10月25日【日报】"><a href="#2021年10月25日【日报】" class="headerlink" title="2021年10月25日【日报】"></a>2021年10月25日【日报】</h6><p>今天把上周末看的论文看完了，是2017年发表在控制汇刊上的，论文中主要的创新点是：①将二维环境下的任务分配转化为三维场景；②改进了SOM中参数调整的方法：减少了参数依赖和特殊情况下不能收敛的问题；③通过贝塞尔曲线对获得的路径进行优化。论文中有很多值得借鉴的地方。</p><h6 id="2021年10月26日【日报】"><a href="#2021年10月26日【日报】" class="headerlink" title="2021年10月26日【日报】"></a>2021年10月26日【日报】</h6><p>今天追踪到昨天论文的作者的另一篇论文，将让task assignment、path planning、track control放在一个系统中，考虑了robots的总路径长度、负载均衡等，其中负载均衡的公式对未来的研究有帮助。</p><h6 id="2021年10月27日【日报】"><a href="#2021年10月27日【日报】" class="headerlink" title="2021年10月27日【日报】"></a>2021年10月27日【日报】</h6><p>今天主要是查阅论文，读论文。看了开会时说的综述文章，找到了几个关于自适应的论文。剩下的时间在看之前的代码，打算改变输入的向量和权重更新的参数。 </p><h6 id="2021年10月28日【日报】"><a href="#2021年10月28日【日报】" class="headerlink" title="2021年10月28日【日报】"></a>2021年10月28日【日报】</h6><p>今天继续查找论文，在数学模型方面，原来想的是将其抽象为MTSP（多旅行商问题），在这个模型方面搜索了一些论文，现在找到了一个解决组合优化一类问题的工具gurobi 。主要还是在一个top期刊上看到的，现在已经安装完成，正在阅读论文。</p><h6 id="2021年10月29日【日报】"><a href="#2021年10月29日【日报】" class="headerlink" title="2021年10月29日【日报】"></a>2021年10月29日【日报】</h6><p>今天的时间把Gurobi安装好了，根据了论文中提供的源码，把环境配置完成。Gurobi是一个很大的优化平台，用来求解大规模的数学问题，昨日看的期刊上将其作为一个对比，说明提出算法的有效性。现在已经能够明白怎么将优化后的数据导出，并绘制效果图。</p>]]></content>
    
    
    <categories>
      
      <category>研究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02--概述</title>
    <link href="/2021/10/29/Ljf%E5%AE%9E%E6%88%98-02-02%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <url>/2021/10/29/Ljf%E5%AE%9E%E6%88%98-02-02%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="02-编码阶段能做什么"><a href="#02-编码阶段能做什么" class="headerlink" title="02 编码阶段能做什么"></a>02 编码阶段能做什么</h3><p>笔记–罗剑峰的C++实战笔记</p><p>C和C++主要的命名方式：sanke_case，小写，单词之间用下划线连接。unordered_set、shrink_to_fit</p><p>建议命名规则</p><ul><li>变量、函数名和名字空间用snake_case,全局变量家 “g_” 前缀</li><li>自定义类型用CanmelCase,成员函数用snake_case，成员变量加 “m_” 前缀</li><li>宏和常量全大写，单词之间使用下划线连接</li><li>尽量不要使用下划线作为变量的前缀或者后缀，很难识别</li></ul><h3 id="03-预处理阶段能做什么：宏定义和条件编译"><a href="#03-预处理阶段能做什么：宏定义和条件编译" class="headerlink" title="03 预处理阶段能做什么：宏定义和条件编译"></a>03 预处理阶段能做什么：宏定义和条件编译</h3><h4 id="预处理编程"><a href="#预处理编程" class="headerlink" title="预处理编程"></a>预处理编程</h4><p>预处理阶段编程的操作目标是 <strong>“源码”</strong> ，用各种指令控制预处理器，把源码改造成另一种形式。</p><p>最常用的预处理指令： <code>#include</code>、<code>#define</code>、<code>#if</code>。虽然都在一个源文件，但是不属于C语言，走的是预处理器，不受C++语法约束。</p><p>预处理编程不用太遵守C++代码风格，不管在函数、类中，永远<strong>顶格写</strong>。</p><ul><li><code>#include</code>:包含文件，可以包含任意文件</li><li><code>#define/#undef</code>:定义一个源码级别的 <strong>“文本替换”</strong>，也就是常说的 <strong>“宏定义”</strong>。</li><li>使用宏的时候一定要谨慎，时刻记着以简化代码、清晰易懂为目标。 <strong>宏是没有作用域概念的，永远全局生效</strong>，对于起临时作用的宏，用完后尽快用 <code>#undef</code> 取消定义。定义宏之前需要先进行检查。</li><li><code>#if/#else#endif</code>:条件编译,通过判断宏的数值产生不同的源码，改变源文件的形态。</li><li>c++头文件中 <code>#pragma once</code></li></ul><h4 id="04-编译阶段能做什么：属性和静态断言"><a href="#04-编译阶段能做什么：属性和静态断言" class="headerlink" title="04 编译阶段能做什么：属性和静态断言"></a>04 编译阶段能做什么：属性和静态断言</h4><p>在c++程序生命周期里的 “编码阶段” 和 “预处理阶段”， 他们的主要工作还是 “文本编辑” ，生成的是 <strong>人类可识别的源码（sourse code）</strong> ,而 “<strong>编译阶段</strong>”的目标是<strong>生成计算机可识别的机器码</strong>。</p><h5 id="编译阶段编程"><a href="#编译阶段编程" class="headerlink" title="编译阶段编程"></a>编译阶段编程</h5><p>编译是预处理后的节点，输入是经过预处理的 C++ 源码，输出的是<strong>二进制可执行文件</strong></p><h5 id="属性（attribute）"><a href="#属性（attribute）" class="headerlink" title="属性（attribute）"></a>属性（attribute）</h5><p>程序员手动指示编译器如何做，将有可能会生成更高效的代码。在C++11之前，标准里没有这样的东西，但GCC、VC等编译器，实现出了自己的“<strong>编译指令</strong>”，在GCC里是 <code>__attribute__</code>，在VC中是 <code>__declspec</code>。  C++11 添加了“属性” 官方版本，理解为给变量、函数、类等 贴上 编译阶段的标签，方便编译器识别处理。</p><p>几个比较有用的属性：</p><ul><li>constructor:函数在<code>main()</code>之前执行，效果有点像是全局对象的<strong>构造</strong>函数</li><li>destructor:函数在 <code>main()</code> 之后执行，类似<strong>析构</strong>函数</li><li>always_inline:要求编译器强制内联函数，作用比inline关键字更强</li><li>hot:标记“<strong>热点</strong>”函数，要求编译器更积极优化</li></ul><h5 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h5><p>还没有读懂，就先记录这么多吧</p><p>在编译阶段计算常数和类型，如果断言失败会导致编译错误，迈向模板元编程的第一步。</p><p>和运行阶段的“<strong>动态断言</strong>”一样，static_assert可以在编译阶段定义各种前置条件，充分利用C++静态类型语言的优势，让编译器执行各种检查，避免把隐患带到运行阶段。</p>]]></content>
    
    
    <categories>
      
      <category>Ljf_C++实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-重新认识C++----生命周期和编程范式</title>
    <link href="/2021/10/29/Ljf%E5%AE%9E%E6%88%98-02-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86c/"/>
    <url>/2021/10/29/Ljf%E5%AE%9E%E6%88%98-02-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86c/</url>
    
    <content type="html"><![CDATA[<h2 id="01-重新认识c-生命周期和编程范式"><a href="#01-重新认识c-生命周期和编程范式" class="headerlink" title="01 重新认识c++:生命周期和编程范式"></a>01 重新认识c++:生命周期和编程范式</h2><h3 id="C-程序的生命周期"><a href="#C-程序的生命周期" class="headerlink" title="C++程序的生命周期"></a>C++程序的生命周期</h3><h4 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h4><p>代码规范、注释规范、设计模式、编程惯用法等</p><h4 id="2-预处理"><a href="#2-预处理" class="headerlink" title="2. 预处理"></a>2. 预处理</h4><p>C++独有的阶段，其他编程语言没有。发挥作用的是  <strong>预处理器</strong> ，其输入是编码节点产生的源码文件，输出是经过 “预处理” 的与源码文件。目的是文字替换</p><h4 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a>3. 编译</h4><p>“编译”和“链接”。生成可以在计算机上运行的二进制机器码，在编译过程中，还会检查C++与语法规则、语义，基本的“静态检查”。</p><h4 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h4><p>编译阶段完成后，有了可执行文件，C++程序进入运行阶段。在运行阶段，进行GDB调试、日志追踪、性能分析等，收集动态的数据，调整设计思路，再返回编码阶段。实现“螺旋式上升”的开发。</p><h3 id="C-语言的编程范式"><a href="#C-语言的编程范式" class="headerlink" title="C++语言的编程范式"></a>C++语言的编程范式</h3><p>编程范式（Paradigm）一种方法论，知道编写代码的一些思路、规则、习惯、定式和常用语等。</p><p>C++是一种<strong>多范式</strong>语言，C++（11/14）支持“面向过程”、“面向对象”、“泛型”、“模板元”、“函数式” 五种主要的编程范式。</p><p><img src="https://gitee.com/luozhiSun/image/raw/master/Luojf_shizhan/01.jpg"></p><p>  <strong>面向过程</strong>是 C++中一个基本的编程范式，来源C语言，比如变量声明、表达式、分支/循环/跳出语句等等</p><p>  <strong>面向对象</strong>是C++一个基本的编程范式，核心思想是 <strong>“抽象”</strong> 和 <strong>”封装“</strong>， 将任务分解撑一个高内聚低耦合的对象，这些对象互相通信协作完成任务，强调对象之间的关系和接口。面向对象的范式包括class 、public、private、virtual、this等类相关的关键，以及构造函数、析构函数、友元函数等概念。</p><p>  <strong>泛型编程</strong>是自STL纳入到C++标准后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，泛型的基础就是<strong>template</strong>关键字，然后是庞大的标准库，比如vector、map、sort等</p>]]></content>
    
    
    <categories>
      
      <category>Ljf_C++实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中数字出现次数--哈希表</title>
    <link href="/2021/07/17/%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2021/07/17/%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h4><p>map是键值对，比如一个人名对应一个学号，可以定义一个字符string 类型的人名为 ‘键’，学号int类型为‘值’，<code>map&lt;string,int&gt;</code></p><p>map会自动将所有的键值对按照从小到大进行排序，使用时需要包含头文件<code>#uinculde&lt;map&gt;</code>。</p><p>map常用的使用方法：</p><p>1。定义一个map,在尖括号内指定类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string,<span class="hljs-keyword">int</span>&gt;m;<br><span class="hljs-comment">//将key为“hello”，value 为2的键值对存入map中</span><br>m[<span class="hljs-string">&quot;hello&quot;</span>]=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>2.使用迭代器进行遍历</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> iter=m.begin();iter!=m.<span class="hljs-keyword">end</span>();iter++)<br>&#123;<br>//通过iter-&gt;<span class="hljs-built_in">first</span>获取键；通过iter-&gt;second获取值<br>    cout&lt;&lt;iter-&gt;<span class="hljs-built_in">first</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.map中元素的个数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h4 id="unordered-map的使用以及与map的区别"><a href="#unordered-map的使用以及与map的区别" class="headerlink" title="unordered_map的使用以及与map的区别"></a>unordered_map的使用以及与map的区别</h4><p>unordered_map在头文件<code>#include&lt;unordered_map&gt;</code>中使用，基本的用法与map一致</p><p>二者区别：map会按照键值对<code>key</code>进行排序，为unordered_map省去了排序的过程，如果刷题时候</p><h4 id="刷题实例"><a href="#刷题实例" class="headerlink" title="刷题实例"></a>刷题实例</h4><p>剑指 Offer 50. 第一个只出现一次的字符</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; map_1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            map_1[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">char</span> ret=<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">auto</span> iter=map_1.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map_1[s[i]]==<span class="hljs-number">1</span>)<br>            &#123;<br>                ret=s[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剑指 Offer 56 - II. 数组中数字出现的次数 II</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-comment">//map中&lt;数字、出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            map[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> iter=map.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(iter!=map.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-comment">//遍历哈希表</span><br>            <span class="hljs-keyword">if</span>(iter-&gt;second==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> iter-&gt;first;<br>            iter++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <link href="/2021/07/16/%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2021/07/16/%E5%88%B7%E9%A2%98-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中只出现一次的两个数字。一个整型数组中除两个数字外，其他数字都出现了两次，找出这两个只出现一次的数字，要求时间复杂度为O(n)，空间复杂度为O(1).</p><p>异或运算的性质：任何一个数字异或自己均为0，</p><p>针对数组中只出现一次的数组可以通过异或进行解决。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>   从头到尾异或数组中的数字，最终得到的结果是两个只出现一次的数字的异或结果；其他数字出现了两次，异或后为0；<br>   由于这两个数字肯定不一样，那么异或的结果肯定不为0，其结果的二进制至少有一位1；<br>   在结果中找到第一位为1的位的位置，记为第n位，将数组中第n位是否为1的分为两个数组。这样就将问题分解为找到数组中只出现一次的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            ret ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> div = <span class="hljs-number">1</span>;<br>        while ((div &amp; ret) == <span class="hljs-number">0</span>)<br>            div &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            <span class="hljs-built_in">if</span> (div &amp; <span class="hljs-built_in">n</span>)<br>                a ^= <span class="hljs-built_in">n</span>;<br>            else<br>                b ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>;<br>        <span class="hljs-built_in">if</span>(a&gt;b)<br>        &#123;<br>            <span class="hljs-built_in">t</span>=a;<br>            a=b;<br>            b=<span class="hljs-built_in">t</span>;<br>        &#125;<br>        return vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;a, b&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tree</title>
    <link href="/2021/07/16/%E5%88%B7%E9%A2%98-tree/"/>
    <url>/2021/07/16/%E5%88%B7%E9%A2%98-tree/</url>
    
    <content type="html"><![CDATA[<p>树的结点包括一个数据元素及若干指向其子树的分支，结点拥有子树数成为结点的度（degree）.树的度是树内各结点的度的最大值。<br>二叉树的5种基本形态：<br><img src="https://gitee.com/luozhiSun/image/raw/master/data_structor/tree2021103001.jpg"><br>数据结构的一种，二叉树通常的几种遍历形式：</p><ul><li>先序遍历： 根-左-右</li><li>中序遍历： 左-根-右</li><li>后序遍历： 左-右-根</li><li>宽度优先遍历：先访问树的第一层节点、第二层，主要通过队列来实现</li></ul><p>上述三种遍历右递归、循环不同的实现方法，递归实现要比循环简单。应该对三种遍历的6种实现方法了解。</p><h4 id="树的重要性质"><a href="#树的重要性质" class="headerlink" title="树的重要性质"></a>树的重要性质</h4><p>(1)在二叉树的第i层上至多有2的（i-1）次幂个结点<br>(2)深度为k的二叉树至多有2的k次幂 -1个结点<br>(3)对任何一颗二叉树，如果终端结点数为n0,度为2的结点数为n2,则n0=n2+1;<br>(4)具有n个结点的完全二叉树的深度为以2为n的对数向下取整+1；</p><h4 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h4><p>二叉搜索树：左子节点总是小于等于根节点，右子节点大于等于根节点</p><p>堆：分为最大堆、最小堆。最大堆中根节点的值最大，最小堆中根节点的值最小，有很多需要快速找到最大值或者最小值的问题可通过堆来解决。</p><p>红黑树：把树中的结点定义为红黑两种颜色，通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。<br>在C++中STL，set、multiset、map、multimap、等数据结构都是根据堆和红黑树实现的。</p><h4 id="二叉树的结构体定义"><a href="#二叉树的结构体定义" class="headerlink" title="二叉树的结构体定义"></a>二叉树的结构体定义</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(NULL),right(NULL)&#123;&#125;<br>    ~<span class="hljs-constructor">TreeNode()</span>&#123;&#125;<span class="hljs-comment">//析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>在二叉树的建立过程中，就是不断扩展节点，建立根节点，由跟结点建立左右子节点，递归的建立子节点的子节点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void Bitree::create<span class="hljs-constructor">BiTree(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>==<span class="hljs-number">999</span>)<br>    &#123;<br>    root=NULL；<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(1)</span>;<br>        <span class="hljs-keyword">if</span>(root==NULL)<br>        &#123;<br>        return;<br>        &#125;<br>        root-&gt;<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>通过递归实现<br>1.先序遍历</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//参数传递指针或者指针的引用都可以</span><br><span class="hljs-keyword">void</span> BiTree::preorder（struct TreeNode *&amp;root)<br>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    preorder(root-&gt;left);<br>    preorder(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.中序遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void BiTree::<span class="hljs-constructor">InOrder(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(root==NULL)<br>    &#123;return；&#125;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.后序遍历</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找和排序</title>
    <link href="/2021/07/15/%E5%88%B7%E9%A2%98-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/15/%E5%88%B7%E9%A2%98-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>查找和排序都是程序设计中经常用到的算法，查找相对而言比较简单：</p><ul><li>顺序查找</li><li>二分查找</li><li>哈希表查找</li><li>二叉排序树查找</li></ul><p>剑指中11中“旋转数组的最小值”和53”在排序数组中查找数字“都可用二分查找算法解决。</p><p>tips:如果要求在排序的数组（部分排序的数组）中查找一个数字或者统计某个数组出现的次数，都可尝试通过二分查找解决。</p><p>哈希表和二叉排序树查找的重点在于考察对应的数据结构而非算法；</p><p>哈希表最主要的优点是利用能够在o（1）的时间内查找某一元素，是效率最高的查找方式，但缺点是，需要额外的空间来实现哈希表。</p><p>与二叉排序树对应的是二叉搜索树</p><p>排序比查找复杂，应对各种排序手法熟悉，能够从额外空间消耗、平均时间复杂度、最差时间复杂度等方面比较优缺点。<br>快速排序的代码</p><ul><li>插入排序</li><li>归并排序</li><li>快速排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找和排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----vector使用</title>
    <link href="/2021/07/12/c++-C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/c++-C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>摘抄—《剑指offer》</p><p>为了解决数组空间效率不高的问题，设计实现了多种动态数组，其中vector即为其中的一个。为了避免浪费，先为数组开辟较小的空间，然后往数组中添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL vector每次扩充时，新的容量都是前一次的两倍）</p><p>动态数组要尽量减少改变容量大小的次数。</p><p>vector是向量类型，可以容纳很多类型的数据，多以称其为容器，是STL的重要成员：使用时需要包含头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span>;</span><br><br><br></code></pre></td></tr></table></figure><h4 id="初始化一个矢量向量"><a href="#初始化一个矢量向量" class="headerlink" title="初始化一个矢量向量"></a>初始化一个矢量向量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-comment">//以创建int 为例</span><br><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt;a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><br><br><br><br><br><span class="hljs-comment">//定义10个整型元素的向量，给每个元素的初始值为1</span><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>，<span class="hljs-number">1</span>);<br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="其他常用到的函数"><a href="#其他常用到的函数" class="headerlink" title="其他常用到的函数"></a>其他常用到的函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-comment">//向量中元素的个数</span><br><br><br>a=<span class="hljs-built_in">size</span>();<br><br><br><br><br><br><span class="hljs-comment">//迭代器输出</span><br><br><br><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt;a = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); it++)<br><br><br>&#123;<br><br><br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><span class="hljs-comment">//返回第一个元素</span><br><br><br>a.<span class="hljs-built_in">front</span>();<br><br><br><span class="hljs-comment">//返回最后一个元素</span><br><br><br>a.<span class="hljs-built_in">back</span>();<br><br><br><br><br><br><br><br><br><span class="hljs-comment">//不使用auto关键字</span><br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br><br><br>&#123;<br><br><br>cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><br><br><br></code></pre></td></tr></table></figure><p>创建vector，向其中添加元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; a;<br><br><br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><br><br></code></pre></td></tr></table></figure><p>二维vector的长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><br>   vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; A;<br><br><br>vector&lt;<span class="hljs-built_in">int</span>&gt; B;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(0)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(1)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(2)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>clear<span class="hljs-literal">()</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(3)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(4)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(5)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><br><br><br><span class="hljs-comment">//输出A中含有的行数:2</span><br><br><br>cout &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br><span class="hljs-comment">//输出每行中含有的数组:3</span><br><br><br>cout &lt;&lt; A<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br></code></pre></td></tr></table></figure><h4 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h4><ul><li>关键字auto在声明变量的时候根据变量的初始值的类型自动分配类型，自动类型的推断发生在编译期，不会造成程序运行时效率的降低。</li></ul><ul><li>可用于声明函数内部的变量类型</li></ul><ul><li>必须在定义时进行初始化，类似于const关键字</li></ul><ul><li>定义一个auto序列类型的变量必须始终在同一个类型</li></ul><ul><li>auto不是一个真正的类型，仅仅是一个占位符，不能使用一些操作函数：sizeof()等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----STL队列queue的使用</title>
    <link href="/2021/07/12/c++-STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/c++-STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>队列在头文件 <code>#include&lt;queue&gt;</code>中，是数据结构中的队列</p><p>主要有一下几种用法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//定义一个空队列</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>    &#123;<br>    <span class="hljs-comment">//将i值入队</span><br>    q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//访问队首元素和队尾元素</span><br>    cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//队列中的元素个数</span><br>    q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//移除队首元素</span><br>    q.<span class="hljs-built_in">pop</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 32---  二叉树广度优先遍历</title>
    <link href="/2021/07/12/%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/2021/07/12/%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="http://https//leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">题目描述</a></p><p>二叉树的从上至下打印（按层打印），二叉树的广度优先搜索（BFS）</p><p>BFS通常借助队列的先入先出的特性实现</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    vector<span class="hljs-tag">&lt;int&gt;</span> levelOrder(TreeNode* root) &#123;<br>        vector <span class="hljs-tag">&lt;int&gt;</span>ret;<br>        if(!root)<br>        &#123;<br>            return ret;<br>        &#125;<br>        queue<span class="hljs-tag">&lt;TreeNode*&gt;</span> q;<br>        q.push(root);<br>        while(q.size())<br>        &#123;<br>            TreeNode * <span class="hljs-keyword">node</span><span class="hljs-title">=q</span>.front();<br>            q.pop();<br>            ret.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>            if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>            &#125;<br>            if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>            &#125;<br>        &#125;<br>        return ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leecode 135 Single Number</title>
    <link href="/2021/07/03/%E5%88%B7%E9%A2%98-leecode135SingleNumber/"/>
    <url>/2021/07/03/%E5%88%B7%E9%A2%98-leecode135SingleNumber/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="http://">https://leetcode.com/problems/single-number/</a><br>找出数组中不相同的数组：给出一个非空整型数组，数组内的每个元素都出现了2次，只有1个数出现了一次，希望使用现行时间0（n）照吃只出现一次的数字。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">input</span>:nums=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">output</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>异或运算是指位与位之间遇到相同的则该位结果位0，不同的表示结果为1。数组nums中每个元素出现两次后，进行位运算后正好为0，最终位运算后的结果为单个的数据：single_data。</p><p> C++中使用^运算表示二进制的异或运算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">4</span>=<span class="hljs-number">6</span><br><span class="hljs-attribute">010</span>^<span class="hljs-number">100</span>=<span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>异或^是一个重要的运算符，大量问题可以利用异或的特点找到解决方案。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> single_data=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            single_data=single_data^nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> single_data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leecode 53.Maximum Subarry</title>
    <link href="/2021/07/03/%E5%88%B7%E9%A2%98-leecode53/"/>
    <url>/2021/07/03/%E5%88%B7%E9%A2%98-leecode53/</url>
    
    <content type="html"><![CDATA[<p><a href="http://">https://leetcode.com/problems/maximum-subarray/</a></p><h4 id="使用动态规划"><a href="#使用动态规划" class="headerlink" title="使用动态规划"></a>使用动态规划</h4><h4 id="添加了输出子序列"><a href="#添加了输出子序列" class="headerlink" title="添加了输出子序列"></a>添加了输出子序列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/***使用动态规划，求数组中nums最大子序列的和；最终输出子序列***/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">int</span> nums[] = &#123; <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span> &#125;;<br><br><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(nums)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(n);<br><br><span class="hljs-keyword">int</span> nums_copy[n] = &#123;&#125;;<br><br><span class="hljs-built_in">memcpy</span>(nums_copy, nums,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(nums));<br><br><span class="hljs-keyword">int</span> max_data = nums[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<br><br>&#123;<br><br>nums[i] += nums[i - <span class="hljs-number">1</span>];<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//找到最大的和，与其值；</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><br>&#123;<br><br><br><br><span class="hljs-keyword">if</span> (max_data &lt; nums[i])<br><br>&#123;<br><br>max_data = nums[i];<br><br>k = i;<br><br>&#125;<br><br>&#125;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k;; i--)<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>)<br><br>&#123;<br><br>t = i;<br><br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><br>&#125;<br><br>cout &lt;&lt; max_data &lt;&lt; endl;<br><br><span class="hljs-comment">//输出最大和的子序列</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t + <span class="hljs-number">1</span>; i &lt;= k; i++)<br><br>cout &lt;&lt; nums_copy[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开课吧3天玩转数据分析</title>
    <link href="/2021/06/19/pyhton-%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2021/06/19/pyhton-%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="python与数据分析基础工具"><a href="#python与数据分析基础工具" class="headerlink" title="python与数据分析基础工具"></a>python与数据分析基础工具</h2><p>如何利用数据驱动业务？？？<br>数字化转型</p><p>数据分析职业发展</p><p>数据工程师-&gt;数据分析师-&gt;数据挖掘工程师-&gt;数据科学家</p><h3 id="python-语言基础操作"><a href="#python-语言基础操作" class="headerlink" title="python 语言基础操作"></a>python 语言基础操作</h3><h3 id="1-1数据结构"><a href="#1-1数据结构" class="headerlink" title="1.1数据结构"></a>1.1数据结构</h3><p>常见的python数据结构包括：元组、列表、字典、集合</p><h4 id="1-1-1元组"><a href="#1-1-1元组" class="headerlink" title="1.1.1元组"></a>1.1.1元组</h4><p>元组是一个固定长度，不可改变的python 序列对象。创建元组最简单的方式，用逗号分隔一列值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">tup</span>=4,5,6<br><span class="hljs-builtin-name">print</span>(tup)<br>(4,5,6)<br></code></pre></td></tr></table></figure><p>嵌套复杂的元组：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">nested_tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(nested_tup)</span></span><br><span class="hljs-function"><span class="hljs-params">((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span>, <span class="hljs-params">(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span>)</span><br></code></pre></td></tr></table></figure><p>可以使用tuple命令，将其他数据结构直接转化为元组</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tuple</span><span class="hljs-params">([<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])</span></span><br>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>将字符串转为元组</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">tur=tuple(&#x27;string&#x27;)<br>print(<span class="hljs-name">tur</span>)<br>(&#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;)<br></code></pre></td></tr></table></figure><p>元组一旦创建，元组中的对象就不能修改了</p><p>元组添加元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=tuple(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;foo&#x27;</span>,[1,2]</span>,True])<br>tup<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">3</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(tup)</span></span><br>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-selector-attr">[1, 2, 3]</span>, True)<br></code></pre></td></tr></table></figure><p>如果将元祖赋值给类似元组的变量，python会尝试拆分等号右边的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c=tup<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>tuple（元组）的应用场景主要有三个：、</p><ol><li>函数的参数和返回值，一个函数可以接收任意多个参数，一次返回多个数据</li><li>格式字符串</li><li>让列表不可以被修改，保护数据</li></ol><h4 id="1-1-2列表"><a href="#1-1-2列表" class="headerlink" title="1.1.2列表"></a>1.1.2列表</h4>]]></content>
    
    
    <categories>
      
      <category>pyhton</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyhton数据结构</tag>
      
      <tag>numpy</tag>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>念</title>
    <link href="/2021/06/17/%E6%B7%AE%E5%8D%97%E6%B4%9B%E6%9E%B3-%E5%BF%B5/"/>
    <url>/2021/06/17/%E6%B7%AE%E5%8D%97%E6%B4%9B%E6%9E%B3-%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="淮南先生与洛枳小姐"><a href="#淮南先生与洛枳小姐" class="headerlink" title="淮南先生与洛枳小姐"></a>淮南先生与洛枳小姐</h2><p>本来想写博客是想着记录研究生的学习之路，但最近似乎没有什么技术学习进展,就先写写我的淮南与洛枳的故事吧~</p><p>最近淮南先生在出差，来找洛枳小姐的计划泡汤了。洛枳小姐企盼许久见面就这么推迟了，毕竟他们已经有两个月的时间没有见面了。她非常生气，也觉得对这段从一开始就异地，到现在为止2年3个月的感情坚持不下去了，于是给淮南先生写了很长很长的一段话。大致意思就是感觉自己不能很好的理解他，希望有一个能在身边陪伴的人。自从淮南先生有了工资后，每天都会给洛枳小姐发红包。一开始是0.01元，洛枳小姐说这象征着他们每天都会再深爱一分。今年春节后，淮南先生给洛枳小姐涨工资了，每天0.52元。</p><p>那天早晨淮南先生依旧给洛枳小姐发了红包，却一句话都没有说。洛枳小姐猜想淮南先生肯定对她很失望，两个人或许就这样了吧，最美好的爱情可能就这样结束了吧。于是，一整天的时间浑浑噩噩，脑海中不断浮现遇见淮南先生的点点滴滴……</p><p>不知怎么，洛枳小姐回想初见淮南先生的画面，顿了一下，才想起那个片段。记不清具体时间了，也忘记了是哪个季节，春、夏初或是秋，只记得是阳光明媚的下午，阳光打在淮南先生的身上，整个人熠熠发光。正是高中生感情懵懂的时候，小女生在那一刻心里就烙下了眼前会发光的男孩~很久之后，洛枳小姐才知晓了男孩的姓名。慢慢地，在写作业的时候碰到男孩名字中的字都会觉得异常亲切，又悄悄的在本子上重复画着那个字；</p><p>日记中开始出现一个男生，昨天遇见他了，今天他穿的蓝色的衣服，明天他有体育课，下周一升国旗的播报会听见他的声音，最近一次的月考他又上榜了,突然感觉他有的时候很孤单，他似乎和好朋友又吵架了……似乎所有他的琐事她都知晓。</p><p>高中两年多的时间，洛枳小姐还是没有让淮南先生知道她的存在，她也不知道原因，可能是自己不是学霸，也并不是校园里漂亮的女孩就只是普通得不能再普通的学生，她啊，也只是众多关注淮南先生的女孩们中的一个微不足道的角色，总之，最后男孩不知道女孩的名字。</p><p>高考成绩出来了，女孩和家里边商量决定复读了。回到高中，熟悉的场景，但是好像找不到曾经熟悉的那个身影了，回想到这，现在思念的感觉似曾相识。几个月之后，女孩淘到了男孩的qq。就像得到了世界上最好的宝贝，满心期待、小心翼翼地在验证消息里输入‘一中校友’，等待男孩的验证通过。是的，那一刻感觉要飞起来，女孩也不知道说什么，但有了好友的关系总是让她兴奋的，因为他们之间总算有了点关系的。那段时间，聊的最多的就是放月假时的三五句话，但洛枳小姐都会收藏、截图保存、放进云盘中。</p><p>2016年8月26日，是淮南先生与洛枳小姐的第一次见面，他们约定在高中校门口。洛枳小姐清晰的记得，那天早上下着雨，是坐亲戚车到的校门口，雨淅淅沥沥的，下得不大不小。洛枳小姐买了一把蓝色的伞，撑着伞在学校门口边走边张望，过来许久，依旧没有淮南先生的消息，准备打道回府。犹豫着是否还继续等待，终于收到了他发过来的消息。他们走了很多路，似乎谈论得并不多，但很舒服，中午吃的米粉。雨过天晴，阳光刺眼灼人，他们在一个凉亭中歇下来……</p><p>2017年2月14日，是淮南先生与洛枳小姐的第二次见面。正月里总要和家人、同学聚聚，日子一天一天推，就巧合地到了情人节尴尬的日子。半年的时间，洛枳小姐曾有了一个男朋友，淮南先生也谈了一次恋爱，最后都分开了，洛枳小姐知道，她是无法放下烙在心里的男孩。中午依旧吃的米粉，然后淮南先生在车站送洛枳回家。</p><p>2017年4月22日，是淮南先生与洛枳小姐的第三次见面。这一天是洛枳小姐的生日，是她有了很久的愿望，希望淮南先生能陪她过一次生日，哪怕就一次。她前一天晚上坐火车，凌晨两点到达北京，淮南先生在车站等她，他们那个晚上都没有睡觉，四点多跑着去天安门看升旗，白天去了故宫、淮南先生的学校……通宵致使的迷迷糊糊，但和淮南先生在一起，那种感觉还是很美好。</p><p>2017年4月26日，淮南先生与洛枳小姐在一起了。<br><img src="https://gitee.com/luozhiSun/image/raw/master/luozhihuainan/nian.jpg"><br>…… ……<br>两人之间已经能接受距离、时间的考验，早已离不开彼此，这点小困难似乎不值一提。其实洛枳小姐在发出长长消息的那一刻就想撤回，但还是任性地想看看淮南先生的反应。</p><p>刚刚淮南先生发语音说，给洛枳小姐准备了礼物（听声音有幸福的味道），由快递小哥送过来，等待礼物中~<br>（ps:背景图是第三次见面，淮南先生拍的，影子里的两个人像不像在牵手~）</p>]]></content>
    
    
    <categories>
      
      <category>淮南洛枳</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/17/hello-world/"/>
    <url>/2021/06/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
