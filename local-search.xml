<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数组中数字出现次数--哈希表</title>
    <link href="/2021/07/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2021/07/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h4><p>map是键值对，比如一个人名对应一个学号，可以定义一个字符string 类型的人名为 ‘键’，学号int类型为‘值’，<code>map&lt;string,int&gt;</code></p><p>map会自动将所有的键值对按照从小到大进行排序，使用时需要包含头文件<code>#uinculde&lt;map&gt;</code>。</p><p>map常用的使用方法：</p><p>1。定义一个map,在尖括号内指定类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string,<span class="hljs-keyword">int</span>&gt;m;<br><span class="hljs-comment">//将key为“hello”，value 为2的键值对存入map中</span><br>m[<span class="hljs-string">&quot;hello&quot;</span>]=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>2.使用迭代器进行遍历</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> iter=m.begin();iter!=m.<span class="hljs-keyword">end</span>();iter++)<br>&#123;<br>//通过iter-&gt;<span class="hljs-built_in">first</span>获取键；通过iter-&gt;second获取值<br>    cout&lt;&lt;iter-&gt;<span class="hljs-built_in">first</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.map中元素的个数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h4 id="unordered-map的使用以及与map的区别"><a href="#unordered-map的使用以及与map的区别" class="headerlink" title="unordered_map的使用以及与map的区别"></a>unordered_map的使用以及与map的区别</h4><p>unordered_map在头文件<code>#include&lt;unordered_map&gt;</code>中使用，基本的用法与map一致</p><p>二者区别：map会按照键值对<code>key</code>进行排序，为unordered_map省去了排序的过程，如果刷题时候</p><h4 id="刷题实例"><a href="#刷题实例" class="headerlink" title="刷题实例"></a>刷题实例</h4><p>剑指 Offer 50. 第一个只出现一次的字符</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; map_1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            map_1[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">char</span> ret=<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">auto</span> iter=map_1.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map_1[s[i]]==<span class="hljs-number">1</span>)<br>            &#123;<br>                ret=s[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剑指 Offer 56 - II. 数组中数字出现的次数 II</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-comment">//map中&lt;数字、出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            map[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> iter=map.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(iter!=map.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-comment">//遍历哈希表</span><br>            <span class="hljs-keyword">if</span>(iter-&gt;second==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> iter-&gt;first;<br>            iter++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <link href="/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中只出现一次的两个数字。一个整型数组中除两个数字外，其他数字都出现了两次，找出这两个只出现一次的数字，要求时间复杂度为O(n)，空间复杂度为O(1).</p><p>异或运算的性质：任何一个数字异或自己均为0，</p><p>针对数组中只出现一次的数组可以通过异或进行解决。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>   从头到尾异或数组中的数字，最终得到的结果是两个只出现一次的数字的异或结果；其他数字出现了两次，异或后为0；<br>   由于这两个数字肯定不一样，那么异或的结果肯定不为0，其结果的二进制至少有一位1；<br>   在结果中找到第一位为1的位的位置，记为第n位，将数组中第n位是否为1的分为两个数组。这样就将问题分解为找到数组中只出现一次的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            ret ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> div = <span class="hljs-number">1</span>;<br>        while ((div &amp; ret) == <span class="hljs-number">0</span>)<br>            div &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            <span class="hljs-built_in">if</span> (div &amp; <span class="hljs-built_in">n</span>)<br>                a ^= <span class="hljs-built_in">n</span>;<br>            else<br>                b ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>;<br>        <span class="hljs-built_in">if</span>(a&gt;b)<br>        &#123;<br>            <span class="hljs-built_in">t</span>=a;<br>            a=b;<br>            b=<span class="hljs-built_in">t</span>;<br>        &#125;<br>        return vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;a, b&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tree</title>
    <link href="/2021/07/16/tree/"/>
    <url>/2021/07/16/tree/</url>
    
    <content type="html"><![CDATA[<p>树的结点包括一个数据元素及若干指向其子树的分支，结点拥有子树数成为结点的度（degree）.树的度是树内各结点的度的最大值。<br>二叉树的5种基本形态：<br><img src="/2021/07/16/tree/01.jpg"><br>数据结构的一种，二叉树通常的几种遍历形式：</p><ul><li>先序遍历： 根-左-右</li><li>中序遍历： 左-根-右</li><li>后序遍历： 左-右-根</li><li>宽度优先遍历：先访问树的第一层节点、第二层，主要通过队列来实现</li></ul><p>上述三种遍历右递归、循环不同的实现方法，递归实现要比循环简单。应该对三种遍历的6种实现方法了解。</p><h4 id="树的重要性质"><a href="#树的重要性质" class="headerlink" title="树的重要性质"></a>树的重要性质</h4><p>(1)在二叉树的第i层上至多有2的（i-1）次幂个结点<br>(2)深度为k的二叉树至多有2的k次幂 -1个结点<br>(3)对任何一颗二叉树，如果终端结点数为n0,度为2的结点数为n2,则n0=n2+1;<br>(4)具有n个结点的完全二叉树的深度为以2为n的对数向下取整+1；</p><h4 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h4><p>二叉搜索树：左子节点总是小于等于根节点，右子节点大于等于根节点</p><p>堆：分为最大堆、最小堆。最大堆中根节点的值最大，最小堆中根节点的值最小，有很多需要快速找到最大值或者最小值的问题可通过堆来解决。</p><p>红黑树：把树中的结点定义为红黑两种颜色，通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。<br>在C++中STL，set、multiset、map、multimap、等数据结构都是根据堆和红黑树实现的。</p><h4 id="二叉树的结构体定义"><a href="#二叉树的结构体定义" class="headerlink" title="二叉树的结构体定义"></a>二叉树的结构体定义</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(NULL),right(NULL)&#123;&#125;<br>    ~<span class="hljs-constructor">TreeNode()</span>&#123;&#125;<span class="hljs-comment">//析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>在二叉树的建立过程中，就是不断扩展节点，建立根节点，由跟结点建立左右子节点，递归的建立子节点的子节点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void Bitree::create<span class="hljs-constructor">BiTree(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>==<span class="hljs-number">999</span>)<br>    &#123;<br>    root=NULL；<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(1)</span>;<br>        <span class="hljs-keyword">if</span>(root==NULL)<br>        &#123;<br>        return;<br>        &#125;<br>        root-&gt;<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>通过递归实现<br>1.先序遍历</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//参数传递指针或者指针的引用都可以</span><br><span class="hljs-keyword">void</span> BiTree::preorder（struct TreeNode *&amp;root)<br>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    preorder(root-&gt;left);<br>    preorder(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.中序遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void BiTree::<span class="hljs-constructor">InOrder(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(root==NULL)<br>    &#123;return；&#125;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.后序遍历</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找和排序</title>
    <link href="/2021/07/15/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/15/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>查找和排序都是程序设计中经常用到的算法，查找相对而言比较简单：</p><ul><li>顺序查找</li><li>二分查找</li><li>哈希表查找</li><li>二叉排序树查找</li></ul><p>剑指中11中“旋转数组的最小值”和53”在排序数组中查找数字“都可用二分查找算法解决。</p><p>tips:如果要求在排序的数组（部分排序的数组）中查找一个数字或者统计某个数组出现的次数，都可尝试通过二分查找解决。</p><p>哈希表和二叉排序树查找的重点在于考察对应的数据结构而非算法；</p><p>哈希表最主要的优点是利用能够在o（1）的时间内查找某一元素，是效率最高的查找方式，但缺点是，需要额外的空间来实现哈希表。</p><p>与二叉排序树对应的是二叉搜索树</p><p>排序比查找复杂，应对各种排序手法熟悉，能够从额外空间消耗、平均时间复杂度、最差时间复杂度等方面比较优缺点。<br>快速排序的代码</p><ul><li>插入排序</li><li>归并排序</li><li>快速排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找和排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----vector使用</title>
    <link href="/2021/07/12/C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>摘抄—《剑指offer》</p><p>为了解决数组空间效率不高的问题，设计实现了多种动态数组，其中vector即为其中的一个。为了避免浪费，先为数组开辟较小的空间，然后往数组中添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL vector每次扩充时，新的容量都是前一次的两倍）</p><p>动态数组要尽量减少改变容量大小的次数。</p><p>vector是向量类型，可以容纳很多类型的数据，多以称其为容器，是STL的重要成员：使用时需要包含头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span>;</span><br><br><br></code></pre></td></tr></table></figure><h4 id="初始化一个矢量向量"><a href="#初始化一个矢量向量" class="headerlink" title="初始化一个矢量向量"></a>初始化一个矢量向量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-comment">//以创建int 为例</span><br><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt;a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><br><br><br><br><br><span class="hljs-comment">//定义10个整型元素的向量，给每个元素的初始值为1</span><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>，<span class="hljs-number">1</span>);<br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="其他常用到的函数"><a href="#其他常用到的函数" class="headerlink" title="其他常用到的函数"></a>其他常用到的函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-comment">//向量中元素的个数</span><br><br><br>a=<span class="hljs-built_in">size</span>();<br><br><br><br><br><br><span class="hljs-comment">//迭代器输出</span><br><br><br><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt;a = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); it++)<br><br><br>&#123;<br><br><br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><span class="hljs-comment">//返回第一个元素</span><br><br><br>a.<span class="hljs-built_in">front</span>();<br><br><br><span class="hljs-comment">//返回最后一个元素</span><br><br><br>a.<span class="hljs-built_in">back</span>();<br><br><br><br><br><br><br><br><br><span class="hljs-comment">//不使用auto关键字</span><br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br><br><br>&#123;<br><br><br>cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><br><br><br></code></pre></td></tr></table></figure><p>创建vector，向其中添加元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; a;<br><br><br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><br><br></code></pre></td></tr></table></figure><p>二维vector的长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><br>   vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; A;<br><br><br>vector&lt;<span class="hljs-built_in">int</span>&gt; B;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(0)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(1)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(2)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>clear<span class="hljs-literal">()</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(3)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(4)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(5)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><br><br><br><span class="hljs-comment">//输出A中含有的行数:2</span><br><br><br>cout &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br><span class="hljs-comment">//输出每行中含有的数组:3</span><br><br><br>cout &lt;&lt; A<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br></code></pre></td></tr></table></figure><h4 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h4><ul><li>关键字auto在声明变量的时候根据变量的初始值的类型自动分配类型，自动类型的推断发生在编译期，不会造成程序运行时效率的降低。</li></ul><ul><li>可用于声明函数内部的变量类型</li></ul><ul><li>必须在定义时进行初始化，类似于const关键字</li></ul><ul><li>定义一个auto序列类型的变量必须始终在同一个类型</li></ul><ul><li>auto不是一个真正的类型，仅仅是一个占位符，不能使用一些操作函数：sizeof()等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----STL队列queue的使用</title>
    <link href="/2021/07/12/STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>队列在头文件 <code>#include&lt;queue&gt;</code>中，是数据结构中的队列</p><p>主要有一下几种用法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//定义一个空队列</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>    &#123;<br>    <span class="hljs-comment">//将i值入队</span><br>    q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//访问队首元素和队尾元素</span><br>    cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//队列中的元素个数</span><br>    q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//移除队首元素</span><br>    q.<span class="hljs-built_in">pop</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 32---  二叉树广度优先遍历</title>
    <link href="/2021/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/2021/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="http://https//leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">题目描述</a></p><p>二叉树的从上至下打印（按层打印），二叉树的广度优先搜索（BFS）</p><p>BFS通常借助队列的先入先出的特性实现</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    vector<span class="hljs-tag">&lt;int&gt;</span> levelOrder(TreeNode* root) &#123;<br>        vector <span class="hljs-tag">&lt;int&gt;</span>ret;<br>        if(!root)<br>        &#123;<br>            return ret;<br>        &#125;<br>        queue<span class="hljs-tag">&lt;TreeNode*&gt;</span> q;<br>        q.push(root);<br>        while(q.size())<br>        &#123;<br>            TreeNode * <span class="hljs-keyword">node</span><span class="hljs-title">=q</span>.front();<br>            q.pop();<br>            ret.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>            if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>            &#125;<br>            if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>            &#125;<br>        &#125;<br>        return ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leecode 135 Single Number</title>
    <link href="/2021/07/03/leecode135SingleNumber/"/>
    <url>/2021/07/03/leecode135SingleNumber/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="http://">https://leetcode.com/problems/single-number/</a><br>找出数组中不相同的数组：给出一个非空整型数组，数组内的每个元素都出现了2次，只有1个数出现了一次，希望使用现行时间0（n）照吃只出现一次的数字。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">input</span>:nums=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">output</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>异或运算是指位与位之间遇到相同的则该位结果位0，不同的表示结果为1。数组nums中每个元素出现两次后，进行位运算后正好为0，最终位运算后的结果为单个的数据：single_data。</p><p> C++中使用^运算表示二进制的异或运算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">4</span>=<span class="hljs-number">6</span><br><span class="hljs-attribute">010</span>^<span class="hljs-number">100</span>=<span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>异或^是一个重要的运算符，大量问题可以利用异或的特点找到解决方案。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> single_data=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            single_data=single_data^nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> single_data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/03/leecode53/"/>
    <url>/2021/07/03/leecode53/</url>
    
    <content type="html"><![CDATA[<hr><p>title: Leecode 53.Maximum Subarry<br>date: 2021-07-03 11:35:50<br>categories: </p><ul><li>“刷题”<br>tags:</li><li>C++</li><li>算法</li><li>leecode</li></ul><hr><p><a href="http://">https://leetcode.com/problems/maximum-subarray/</a></p><h4 id="使用动态规划"><a href="#使用动态规划" class="headerlink" title="使用动态规划"></a>使用动态规划</h4><h4 id="添加了输出子序列"><a href="#添加了输出子序列" class="headerlink" title="添加了输出子序列"></a>添加了输出子序列</h4><pre><code>/***使用动态规划，求数组中nums最大子序列的和；最终输出子序列***/#include&lt;iostream&gt;using namespace std;int main()&#123;    int nums[] = &#123; -2, 1, -3, 4, -1, 2, 1, -5, 4 &#125;;        const int n = sizeof(nums)/sizeof(n);    int nums_copy[n] = &#123;&#125;;    memcpy(nums_copy, nums,sizeof(nums));    int max_data = nums[0];    for (int i = 1; i &lt; n; i++)    &#123;        if (nums[i - 1] &gt; 0)        &#123;            nums[i] += nums[i - 1];        &#125;    &#125;    //找到最大的和，与其值；    int k = 0;    for (int i = 0; i &lt; n; i++)    &#123;                if (max_data &lt; nums[i])        &#123;            max_data = nums[i];            k = i;        &#125;    &#125;    cout &lt;&lt; endl;    int t = 0;    for (int i = k;; i--)    &#123;        if (nums[i] &lt; 0)        &#123;            t = i;            break;        &#125;    &#125;    cout &lt;&lt; max_data &lt;&lt; endl;    //输出最大和的子序列    for (int i = t + 1; i &lt;= k; i++)        cout &lt;&lt; nums_copy[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开课吧3天玩转数据分析</title>
    <link href="/2021/06/19/%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2021/06/19/%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="python与数据分析基础工具"><a href="#python与数据分析基础工具" class="headerlink" title="python与数据分析基础工具"></a>python与数据分析基础工具</h2><p>如何利用数据驱动业务？？？<br>数字化转型</p><p>数据分析职业发展</p><p>数据工程师-&gt;数据分析师-&gt;数据挖掘工程师-&gt;数据科学家</p><h3 id="python-语言基础操作"><a href="#python-语言基础操作" class="headerlink" title="python 语言基础操作"></a>python 语言基础操作</h3><h3 id="1-1数据结构"><a href="#1-1数据结构" class="headerlink" title="1.1数据结构"></a>1.1数据结构</h3><p>常见的python数据结构包括：元组、列表、字典、集合</p><h4 id="1-1-1元组"><a href="#1-1-1元组" class="headerlink" title="1.1.1元组"></a>1.1.1元组</h4><p>元组是一个固定长度，不可改变的python 序列对象。创建元组最简单的方式，用逗号分隔一列值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">tup</span>=4,5,6<br><span class="hljs-builtin-name">print</span>(tup)<br>(4,5,6)<br></code></pre></td></tr></table></figure><p>嵌套复杂的元组：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">nested_tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(nested_tup)</span></span><br><span class="hljs-function"><span class="hljs-params">((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span>, <span class="hljs-params">(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span>)</span><br></code></pre></td></tr></table></figure><p>可以使用tuple命令，将其他数据结构直接转化为元组</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tuple</span><span class="hljs-params">([<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])</span></span><br>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>将字符串转为元组</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">tur=tuple(&#x27;string&#x27;)<br>print(<span class="hljs-name">tur</span>)<br>(&#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;)<br></code></pre></td></tr></table></figure><p>元组一旦创建，元组中的对象就不能修改了</p><p>元组添加元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=tuple(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;foo&#x27;</span>,[1,2]</span>,True])<br>tup<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">3</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(tup)</span></span><br>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-selector-attr">[1, 2, 3]</span>, True)<br></code></pre></td></tr></table></figure><p>如果将元祖赋值给类似元组的变量，python会尝试拆分等号右边的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c=tup<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>tuple（元组）的应用场景主要有三个：、</p><ol><li>函数的参数和返回值，一个函数可以接收任意多个参数，一次返回多个数据</li><li>格式字符串</li><li>让列表不可以被修改，保护数据</li></ol><h4 id="1-1-2列表"><a href="#1-1-2列表" class="headerlink" title="1.1.2列表"></a>1.1.2列表</h4>]]></content>
    
    
    <categories>
      
      <category>pyhton</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyhton数据结构</tag>
      
      <tag>numpy</tag>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>念</title>
    <link href="/2021/06/17/%E5%BF%B5/"/>
    <url>/2021/06/17/%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="淮南先生与洛枳小姐"><a href="#淮南先生与洛枳小姐" class="headerlink" title="淮南先生与洛枳小姐"></a>淮南先生与洛枳小姐</h2><p>本来想写博客是想着记录研究生的学习之路，但最近似乎没有什么技术学习进展,就先写写我的淮南与洛枳的故事吧~</p><p>最近淮南先生在出差，来找洛枳小姐的计划泡汤了。洛枳小姐企盼许久见面就这么推迟了，毕竟他们已经有两个月的时间没有见面了。她非常生气，也觉得对这段从一开始就异地，到现在为止2年3个月的感情坚持不下去了，于是给淮南先生写了很长很长的一段话。大致意思就是感觉自己不能很好的理解他，希望有一个能在身边陪伴的人。自从淮南先生有了工资后，每天都会给洛枳小姐发红包。一开始是0.01元，洛枳小姐说这象征着他们每天都会再深爱一分。今年春节后，淮南先生给洛枳小姐涨工资了，每天0.52元。</p><p>那天早晨淮南先生依旧给洛枳小姐发了红包，却一句话都没有说。洛枳小姐猜想淮南先生肯定对她很失望，两个人或许就这样了吧，最美好的爱情可能就这样结束了吧。于是，一整天的时间浑浑噩噩，脑海中不断浮现遇见淮南先生的点点滴滴……</p><p>不知怎么，洛枳小姐回想初见淮南先生的画面，顿了一下，才想起那个片段。记不清具体时间了，也忘记了是哪个季节，春、夏初或是秋，只记得是阳光明媚的下午，阳光打在淮南先生的身上，整个人熠熠发光。正是高中生感情懵懂的时候，小女生在那一刻心里就烙下了眼前会发光的男孩~很久之后，洛枳小姐才知晓了男孩的姓名。慢慢地，在写作业的时候碰到男孩名字中的字都会觉得异常亲切，又悄悄的在本子上重复画着那个字；</p><p>日记中开始出现一个男生，昨天遇见他了，今天他穿的蓝色的衣服，明天他有体育课，下周一升国旗的播报会听见他的声音，最近一次的月考他又上榜了,突然感觉他有的时候很孤单，他似乎和好朋友又吵架了……似乎所有他的琐事她都知晓。</p><p>高中两年多的时间，洛枳小姐还是没有让淮南先生知道她的存在，她也不知道原因，可能是自己不是学霸，也并不是校园里漂亮的女孩就只是普通得不能再普通的学生，她啊，也只是众多关注淮南先生的女孩们中的一个微不足道的角色，总之，最后男孩不知道女孩的名字。</p><p>高考成绩出来了，女孩和家里边商量决定复读了。回到高中，熟悉的场景，但是好像找不到曾经熟悉的那个身影了，回想到这，现在思念的感觉似曾相识。几个月之后，女孩淘到了男孩的qq。就像得到了世界上最好的宝贝，满心期待、小心翼翼地在验证消息里输入‘一中校友’，等待男孩的验证通过。是的，那一刻感觉要飞起来，女孩也不知道说什么，但有了好友的关系总是让她兴奋的，因为他们之间总算有了点关系的。那段时间，聊的最多的就是放月假时的三五句话，但洛枳小姐都会收藏、截图保存、放进云盘中。</p><p>2016年8月26日，是淮南先生与洛枳小姐的第一次见面，他们约定在高中校门口。洛枳小姐清晰的记得，那天早上下着雨，是坐亲戚车到的校门口，雨淅淅沥沥的，下得不大不小。洛枳小姐买了一把蓝色的伞，撑着伞在学校门口边走边张望，过来许久，依旧没有淮南先生的消息，准备打道回府。犹豫着是否还继续等待，终于收到了他发过来的消息。他们走了很多路，似乎谈论得并不多，但很舒服，中午吃的米粉。雨过天晴，阳光刺眼灼人，他们在一个凉亭中歇下来……</p><p>2017年2月14日，是淮南先生与洛枳小姐的第二次见面。正月里总要和家人、同学聚聚，日子一天一天推，就巧合地到了情人节尴尬的日子。半年的时间，洛枳小姐曾有了一个男朋友，淮南先生也谈了一次恋爱，最后都分开了，洛枳小姐知道，她是无法放下烙在心里的男孩。中午依旧吃的米粉，然后淮南先生在车站送洛枳回家。</p><p>2017年4月22日，是淮南先生与洛枳小姐的第三次见面。这一天是洛枳小姐的生日，是她有了很久的愿望，希望淮南先生能陪她过一次生日，哪怕就一次。她前一天晚上坐火车，凌晨两点到达北京，淮南先生在车站等她，他们那个晚上都没有睡觉，四点多跑着去天安门看升旗，白天去了故宫、淮南先生的学校……通宵致使的迷迷糊糊，但和淮南先生在一起，那种感觉还是很美好。</p><p>2017年4月26日，淮南先生与洛枳小姐在一起了。<br><img src="/2021/06/17/%E5%BF%B5/nian.jpg"><br>…… ……<br>两人之间已经能接受距离、时间的考验，早已离不开彼此，这点小困难似乎不值一提。其实洛枳小姐在发出长长消息的那一刻就想撤回，但还是任性地想看看淮南先生的反应。</p><p>刚刚淮南先生发语音说，给洛枳小姐准备了礼物（听声音有幸福的味道），由快递小哥送过来，等待礼物中~<br>（ps:背景图是第三次见面，淮南先生拍的，影子里的两个人像不像在牵手~）</p>]]></content>
    
    
    <categories>
      
      <category>淮南洛枳</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/17/hello-world/"/>
    <url>/2021/06/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
