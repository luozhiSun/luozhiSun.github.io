<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>02--概述</title>
    <link href="/2021/10/29/02-02%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <url>/2021/10/29/02-02%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="02-编码阶段能做什么"><a href="#02-编码阶段能做什么" class="headerlink" title="02 编码阶段能做什么"></a>02 编码阶段能做什么</h3><p>笔记–罗剑峰的C++实战笔记</p><p>C和C++主要的命名方式：sanke_case，小写，单词之间用下划线连接。unordered_set、shrink_to_fit</p><p>建议命名规则</p><ul><li>变量、函数名和名字空间用snake_case,全局变量家 “g_” 前缀</li><li>自定义类型用CanmelCase,成员函数用snake_case，成员变量加 “m_” 前缀</li><li>宏和常量全大写，单词之间使用下划线连接</li><li>尽量不要使用下划线作为变量的前缀或者后缀，很难识别</li></ul><h3 id="03-预处理阶段能做什么：宏定义和条件编译"><a href="#03-预处理阶段能做什么：宏定义和条件编译" class="headerlink" title="03 预处理阶段能做什么：宏定义和条件编译"></a>03 预处理阶段能做什么：宏定义和条件编译</h3><h4 id="预处理编程"><a href="#预处理编程" class="headerlink" title="预处理编程"></a>预处理编程</h4><p>预处理阶段编程的操作目标是 <strong>“源码”</strong> ，用各种指令控制预处理器，把源码改造成另一种形式。</p><p>最常用的预处理指令： <code>#include</code>、<code>#define</code>、<code>#if</code>。虽然都在一个源文件，但是不属于C语言，走的是预处理器，不受C++语法约束。</p><p>预处理编程不用太遵守C++代码风格，不管在函数、类中，永远<strong>顶格写</strong>。</p><ul><li><code>#include</code>:包含文件，可以包含任意文件</li><li><code>#define/#undef</code>:定义一个源码级别的 <strong>“文本替换”</strong>，也就是常说的 <strong>“宏定义”</strong>。</li><li>使用宏的时候一定要谨慎，时刻记着以简化代码、清晰易懂为目标。 <strong>宏是没有作用域概念的，永远全局生效</strong>，对于起临时作用的宏，用完后尽快用 <code>#undef</code> 取消定义。定义宏之前需要先进行检查。</li><li><code>#if/#else#endif</code>:条件编译,通过判断宏的数值产生不同的源码，改变源文件的形态。</li><li>c++头文件中 <code>#pragma once</code></li></ul><h4 id="04-编译阶段能做什么：属性和静态断言"><a href="#04-编译阶段能做什么：属性和静态断言" class="headerlink" title="04 编译阶段能做什么：属性和静态断言"></a>04 编译阶段能做什么：属性和静态断言</h4><p>在c++程序生命周期里的 “编码阶段” 和 “预处理阶段”， 他们的主要工作还是 “文本编辑” ，生成的是 <strong>人类可识别的源码（sourse code）</strong> ,而 “<strong>编译阶段</strong>”的目标是<strong>生成计算机可识别的机器码</strong>。</p><h5 id="编译阶段编程"><a href="#编译阶段编程" class="headerlink" title="编译阶段编程"></a>编译阶段编程</h5><p>编译是预处理后的节点，输入是经过预处理的 C++ 源码，输出的是<strong>二进制可执行文件</strong></p><h5 id="属性（attribute）"><a href="#属性（attribute）" class="headerlink" title="属性（attribute）"></a>属性（attribute）</h5><p>程序员手动指示编译器如何做，将有可能会生成更高效的代码。在C++11之前，标准里没有这样的东西，但GCC、VC等编译器，实现出了自己的“<strong>编译指令</strong>”，在GCC里是 <code>__attribute__</code>，在VC中是 <code>__declspec</code>。  C++11 添加了“属性” 官方版本，理解为给变量、函数、类等 贴上 编译阶段的标签，方便编译器识别处理。</p><p>几个比较有用的属性：</p><ul><li>constructor:函数在<code>main()</code>之前执行，效果有点像是全局对象的<strong>构造</strong>函数</li><li>destructor:函数在 <code>main()</code> 之后执行，类似<strong>析构</strong>函数</li><li>always_inline:要求编译器强制内联函数，作用比inline关键字更强</li><li>hot:标记“<strong>热点</strong>”函数，要求编译器更积极优化</li></ul><h5 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h5><p>还没有读懂，就先记录这么多吧</p><p>在编译阶段计算常数和类型，如果断言失败会导致编译错误，迈向模板元编程的第一步。</p><p>和运行阶段的“<strong>动态断言</strong>”一样，static_assert可以在编译阶段定义各种前置条件，充分利用C++静态类型语言的优势，让编译器执行各种检查，避免把隐患带到运行阶段。</p>]]></content>
    
    
    <categories>
      
      <category>Ljf_C++实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-重新认识C++----生命周期和编程范式</title>
    <link href="/2021/10/29/02-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86c/"/>
    <url>/2021/10/29/02-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86c/</url>
    
    <content type="html"><![CDATA[<h2 id="01-重新认识c-生命周期和编程范式"><a href="#01-重新认识c-生命周期和编程范式" class="headerlink" title="01 重新认识c++:生命周期和编程范式"></a>01 重新认识c++:生命周期和编程范式</h2><h3 id="C-程序的生命周期"><a href="#C-程序的生命周期" class="headerlink" title="C++程序的生命周期"></a>C++程序的生命周期</h3><h4 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h4><p>代码规范、注释规范、设计模式、编程惯用法等</p><h4 id="2-预处理"><a href="#2-预处理" class="headerlink" title="2. 预处理"></a>2. 预处理</h4><p>C++独有的阶段，其他编程语言没有。发挥作用的是  <strong>预处理器</strong> ，其输入是编码节点产生的源码文件，输出是经过 “预处理” 的与源码文件。目的是文字替换</p><h4 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a>3. 编译</h4><p>“编译”和“链接”。生成可以在计算机上运行的二进制机器码，在编译过程中，还会检查C++与语法规则、语义，基本的“静态检查”。</p><h4 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h4><p>编译阶段完成后，有了可执行文件，C++程序进入运行阶段。在运行阶段，进行GDB调试、日志追踪、性能分析等，收集动态的数据，调整设计思路，再返回编码阶段。实现“螺旋式上升”的开发。</p><h3 id="C-语言的编程范式"><a href="#C-语言的编程范式" class="headerlink" title="C++语言的编程范式"></a>C++语言的编程范式</h3><p>编程范式（Paradigm）一种方法论，知道编写代码的一些思路、规则、习惯、定式和常用语等。</p><p>C++是一种<strong>多范式</strong>语言，C++（11/14）支持“面向过程”、“面向对象”、“泛型”、“模板元”、“函数式” 五种主要的编程范式。</p><p><img src="/../img/01.jfif"></p><p>  <strong>面向过程</strong>是 C++中一个基本的编程范式，来源C语言，比如变量声明、表达式、分支/循环/跳出语句等等</p><p>  <strong>面向对象</strong>是C++一个基本的编程范式，核心思想是 <strong>“抽象”</strong> 和 <strong>”封装“</strong>， 将任务分解撑一个高内聚低耦合的对象，这些对象互相通信协作完成任务，强调对象之间的关系和接口。面向对象的范式包括class 、public、private、virtual、this等类相关的关键，以及构造函数、析构函数、友元函数等概念。</p><p>  <strong>泛型编程</strong>是自STL纳入到C++标准后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，泛型的基础就是<strong>template</strong>关键字，然后是庞大的标准库，比如vector、map、sort等</p>]]></content>
    
    
    <categories>
      
      <category>Ljf_C++实战</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中数字出现次数--哈希表</title>
    <link href="/2021/07/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2021/07/17/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h4><p>map是键值对，比如一个人名对应一个学号，可以定义一个字符string 类型的人名为 ‘键’，学号int类型为‘值’，<code>map&lt;string,int&gt;</code></p><p>map会自动将所有的键值对按照从小到大进行排序，使用时需要包含头文件<code>#uinculde&lt;map&gt;</code>。</p><p>map常用的使用方法：</p><p>1。定义一个map,在尖括号内指定类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string,<span class="hljs-keyword">int</span>&gt;m;<br><span class="hljs-comment">//将key为“hello”，value 为2的键值对存入map中</span><br>m[<span class="hljs-string">&quot;hello&quot;</span>]=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>2.使用迭代器进行遍历</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> iter=m.begin();iter!=m.<span class="hljs-keyword">end</span>();iter++)<br>&#123;<br>//通过iter-&gt;<span class="hljs-built_in">first</span>获取键；通过iter-&gt;second获取值<br>    cout&lt;&lt;iter-&gt;<span class="hljs-built_in">first</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;iter-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.map中元素的个数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h4 id="unordered-map的使用以及与map的区别"><a href="#unordered-map的使用以及与map的区别" class="headerlink" title="unordered_map的使用以及与map的区别"></a>unordered_map的使用以及与map的区别</h4><p>unordered_map在头文件<code>#include&lt;unordered_map&gt;</code>中使用，基本的用法与map一致</p><p>二者区别：map会按照键值对<code>key</code>进行排序，为unordered_map省去了排序的过程，如果刷题时候</p><h4 id="刷题实例"><a href="#刷题实例" class="headerlink" title="刷题实例"></a>刷题实例</h4><p>剑指 Offer 50. 第一个只出现一次的字符</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; map_1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            map_1[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">char</span> ret=<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">auto</span> iter=map_1.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map_1[s[i]]==<span class="hljs-number">1</span>)<br>            &#123;<br>                ret=s[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>剑指 Offer 56 - II. 数组中数字出现的次数 II</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; map;<br>        <span class="hljs-comment">//map中&lt;数字、出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            map[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> iter=map.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span>(iter!=map.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-comment">//遍历哈希表</span><br>            <span class="hljs-keyword">if</span>(iter-&gt;second==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> iter-&gt;first;<br>            iter++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中只出现一次的两个数字</title>
    <link href="/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/2021/07/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中只出现一次的两个数字。一个整型数组中除两个数字外，其他数字都出现了两次，找出这两个只出现一次的数字，要求时间复杂度为O(n)，空间复杂度为O(1).</p><p>异或运算的性质：任何一个数字异或自己均为0，</p><p>针对数组中只出现一次的数组可以通过异或进行解决。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>   从头到尾异或数组中的数字，最终得到的结果是两个只出现一次的数字的异或结果；其他数字出现了两次，异或后为0；<br>   由于这两个数字肯定不一样，那么异或的结果肯定不为0，其结果的二进制至少有一位1；<br>   在结果中找到第一位为1的位的位置，记为第n位，将数组中第n位是否为1的分为两个数组。这样就将问题分解为找到数组中只出现一次的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            ret ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> div = <span class="hljs-number">1</span>;<br>        while ((div &amp; ret) == <span class="hljs-number">0</span>)<br>            div &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> <span class="hljs-symbol">:</span> array)<br>            <span class="hljs-built_in">if</span> (div &amp; <span class="hljs-built_in">n</span>)<br>                a ^= <span class="hljs-built_in">n</span>;<br>            else<br>                b ^= <span class="hljs-built_in">n</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>;<br>        <span class="hljs-built_in">if</span>(a&gt;b)<br>        &#123;<br>            <span class="hljs-built_in">t</span>=a;<br>            a=b;<br>            b=<span class="hljs-built_in">t</span>;<br>        &#125;<br>        return vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;a, b&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tree</title>
    <link href="/2021/07/16/tree/"/>
    <url>/2021/07/16/tree/</url>
    
    <content type="html"><![CDATA[<p>树的结点包括一个数据元素及若干指向其子树的分支，结点拥有子树数成为结点的度（degree）.树的度是树内各结点的度的最大值。<br>二叉树的5种基本形态：<br><img src="/2021/07/16/tree/01.jpg"><br>数据结构的一种，二叉树通常的几种遍历形式：</p><ul><li>先序遍历： 根-左-右</li><li>中序遍历： 左-根-右</li><li>后序遍历： 左-右-根</li><li>宽度优先遍历：先访问树的第一层节点、第二层，主要通过队列来实现</li></ul><p>上述三种遍历右递归、循环不同的实现方法，递归实现要比循环简单。应该对三种遍历的6种实现方法了解。</p><h4 id="树的重要性质"><a href="#树的重要性质" class="headerlink" title="树的重要性质"></a>树的重要性质</h4><p>(1)在二叉树的第i层上至多有2的（i-1）次幂个结点<br>(2)深度为k的二叉树至多有2的k次幂 -1个结点<br>(3)对任何一颗二叉树，如果终端结点数为n0,度为2的结点数为n2,则n0=n2+1;<br>(4)具有n个结点的完全二叉树的深度为以2为n的对数向下取整+1；</p><h4 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h4><p>二叉搜索树：左子节点总是小于等于根节点，右子节点大于等于根节点</p><p>堆：分为最大堆、最小堆。最大堆中根节点的值最大，最小堆中根节点的值最小，有很多需要快速找到最大值或者最小值的问题可通过堆来解决。</p><p>红黑树：把树中的结点定义为红黑两种颜色，通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。<br>在C++中STL，set、multiset、map、multimap、等数据结构都是根据堆和红黑树实现的。</p><h4 id="二叉树的结构体定义"><a href="#二叉树的结构体定义" class="headerlink" title="二叉树的结构体定义"></a>二叉树的结构体定义</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-keyword">struct</span> TreeNode&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-constructor">TreeNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>:<span class="hljs-keyword">val</span>(x),left(NULL),right(NULL)&#123;&#125;<br>    ~<span class="hljs-constructor">TreeNode()</span>&#123;&#125;<span class="hljs-comment">//析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h4><p>在二叉树的建立过程中，就是不断扩展节点，建立根节点，由跟结点建立左右子节点，递归的建立子节点的子节点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void Bitree::create<span class="hljs-constructor">BiTree(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>==<span class="hljs-number">999</span>)<br>    &#123;<br>    root=NULL；<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(1)</span>;<br>        <span class="hljs-keyword">if</span>(root==NULL)<br>        &#123;<br>        return;<br>        &#125;<br>        root-&gt;<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>        create<span class="hljs-constructor">BiTree(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>通过递归实现<br>1.先序遍历</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//参数传递指针或者指针的引用都可以</span><br><span class="hljs-keyword">void</span> BiTree::preorder（struct TreeNode *&amp;root)<br>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    preorder(root-&gt;left);<br>    preorder(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.中序遍历</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void BiTree::<span class="hljs-constructor">InOrder(<span class="hljs-params">struct</span> <span class="hljs-operator">*</span> &amp;<span class="hljs-params">root</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span>(root==NULL)<br>    &#123;return；&#125;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-constructor">InOrder(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.后序遍历</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找和排序</title>
    <link href="/2021/07/15/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/15/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>查找和排序都是程序设计中经常用到的算法，查找相对而言比较简单：</p><ul><li>顺序查找</li><li>二分查找</li><li>哈希表查找</li><li>二叉排序树查找</li></ul><p>剑指中11中“旋转数组的最小值”和53”在排序数组中查找数字“都可用二分查找算法解决。</p><p>tips:如果要求在排序的数组（部分排序的数组）中查找一个数字或者统计某个数组出现的次数，都可尝试通过二分查找解决。</p><p>哈希表和二叉排序树查找的重点在于考察对应的数据结构而非算法；</p><p>哈希表最主要的优点是利用能够在o（1）的时间内查找某一元素，是效率最高的查找方式，但缺点是，需要额外的空间来实现哈希表。</p><p>与二叉排序树对应的是二叉搜索树</p><p>排序比查找复杂，应对各种排序手法熟悉，能够从额外空间消耗、平均时间复杂度、最差时间复杂度等方面比较优缺点。<br>快速排序的代码</p><ul><li>插入排序</li><li>归并排序</li><li>快速排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找和排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----vector使用</title>
    <link href="/2021/07/12/C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/C-%E4%B8%ADvector%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>摘抄—《剑指offer》</p><p>为了解决数组空间效率不高的问题，设计实现了多种动态数组，其中vector即为其中的一个。为了避免浪费，先为数组开辟较小的空间，然后往数组中添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL vector每次扩充时，新的容量都是前一次的两倍）</p><p>动态数组要尽量减少改变容量大小的次数。</p><p>vector是向量类型，可以容纳很多类型的数据，多以称其为容器，是STL的重要成员：使用时需要包含头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span>;</span><br><br><br></code></pre></td></tr></table></figure><h4 id="初始化一个矢量向量"><a href="#初始化一个矢量向量" class="headerlink" title="初始化一个矢量向量"></a>初始化一个矢量向量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-comment">//以创建int 为例</span><br><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt;a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><br><br><br><br><br><span class="hljs-comment">//定义10个整型元素的向量，给每个元素的初始值为1</span><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>，<span class="hljs-number">1</span>);<br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="其他常用到的函数"><a href="#其他常用到的函数" class="headerlink" title="其他常用到的函数"></a>其他常用到的函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><span class="hljs-comment">//向量中元素的个数</span><br><br><br>a=<span class="hljs-built_in">size</span>();<br><br><br><br><br><br><span class="hljs-comment">//迭代器输出</span><br><br><br><br><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt;a = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it != a.<span class="hljs-built_in">end</span>(); it++)<br><br><br>&#123;<br><br><br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><span class="hljs-comment">//返回第一个元素</span><br><br><br>a.<span class="hljs-built_in">front</span>();<br><br><br><span class="hljs-comment">//返回最后一个元素</span><br><br><br>a.<span class="hljs-built_in">back</span>();<br><br><br><br><br><br><br><br><br><span class="hljs-comment">//不使用auto关键字</span><br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br><br><br>&#123;<br><br><br>cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><br><br>&#125;<br><br><br><br><br><br></code></pre></td></tr></table></figure><p>创建vector，向其中添加元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br>vector &lt;<span class="hljs-keyword">int</span>&gt; a;<br><br><br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><br><br></code></pre></td></tr></table></figure><p>二维vector的长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><br>   vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; A;<br><br><br>vector&lt;<span class="hljs-built_in">int</span>&gt; B;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(0)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(1)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(2)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>clear<span class="hljs-literal">()</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(3)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(4)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>push<span class="hljs-constructor">_back(5)</span>;<br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>push<span class="hljs-constructor">_back(B)</span>;<br><br><br><br><br><br><span class="hljs-comment">//输出A中含有的行数:2</span><br><br><br>cout &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br><span class="hljs-comment">//输出每行中含有的数组:3</span><br><br><br>cout &lt;&lt; A<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span> &lt;&lt; endl;<br><br><br></code></pre></td></tr></table></figure><h4 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h4><ul><li>关键字auto在声明变量的时候根据变量的初始值的类型自动分配类型，自动类型的推断发生在编译期，不会造成程序运行时效率的降低。</li></ul><ul><li>可用于声明函数内部的变量类型</li></ul><ul><li>必须在定义时进行初始化，类似于const关键字</li></ul><ul><li>定义一个auto序列类型的变量必须始终在同一个类型</li></ul><ul><li>auto不是一个真正的类型，仅仅是一个占位符，不能使用一些操作函数：sizeof()等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++----STL队列queue的使用</title>
    <link href="/2021/07/12/STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/12/STL%E9%98%9F%E5%88%97quene%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>队列在头文件 <code>#include&lt;queue&gt;</code>中，是数据结构中的队列</p><p>主要有一下几种用法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//定义一个空队列</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)<br>    &#123;<br>    <span class="hljs-comment">//将i值入队</span><br>    q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//访问队首元素和队尾元素</span><br>    cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//队列中的元素个数</span><br>    q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//移除队首元素</span><br>    q.<span class="hljs-built_in">pop</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 32---  二叉树广度优先遍历</title>
    <link href="/2021/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <url>/2021/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="http://https//leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">题目描述</a></p><p>二叉树的从上至下打印（按层打印），二叉树的广度优先搜索（BFS）</p><p>BFS通常借助队列的先入先出的特性实现</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    vector<span class="hljs-tag">&lt;int&gt;</span> levelOrder(TreeNode* root) &#123;<br>        vector <span class="hljs-tag">&lt;int&gt;</span>ret;<br>        if(!root)<br>        &#123;<br>            return ret;<br>        &#125;<br>        queue<span class="hljs-tag">&lt;TreeNode*&gt;</span> q;<br>        q.push(root);<br>        while(q.size())<br>        &#123;<br>            TreeNode * <span class="hljs-keyword">node</span><span class="hljs-title">=q</span>.front();<br>            q.pop();<br>            ret.push_back(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;val</span>);<br>            if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>            &#125;<br>            if (<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>)<br>            &#123;<br>                q.push(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>            &#125;<br>        &#125;<br>        return ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leecode 135 Single Number</title>
    <link href="/2021/07/03/leecode135SingleNumber/"/>
    <url>/2021/07/03/leecode135SingleNumber/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="http://">https://leetcode.com/problems/single-number/</a><br>找出数组中不相同的数组：给出一个非空整型数组，数组内的每个元素都出现了2次，只有1个数出现了一次，希望使用现行时间0（n）照吃只出现一次的数字。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">input</span>:nums=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-attribute">output</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>异或运算是指位与位之间遇到相同的则该位结果位0，不同的表示结果为1。数组nums中每个元素出现两次后，进行位运算后正好为0，最终位运算后的结果为单个的数据：single_data。</p><p> C++中使用^运算表示二进制的异或运算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">4</span>=<span class="hljs-number">6</span><br><span class="hljs-attribute">010</span>^<span class="hljs-number">100</span>=<span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>异或^是一个重要的运算符，大量问题可以利用异或的特点找到解决方案。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> single_data=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            single_data=single_data^nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> single_data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leecode 53.Maximum Subarry</title>
    <link href="/2021/07/03/leecode53/"/>
    <url>/2021/07/03/leecode53/</url>
    
    <content type="html"><![CDATA[<p><a href="http://">https://leetcode.com/problems/maximum-subarray/</a></p><h4 id="使用动态规划"><a href="#使用动态规划" class="headerlink" title="使用动态规划"></a>使用动态规划</h4><h4 id="添加了输出子序列"><a href="#添加了输出子序列" class="headerlink" title="添加了输出子序列"></a>添加了输出子序列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">/***使用动态规划，求数组中nums最大子序列的和；最终输出子序列***/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">int</span> nums[] = &#123; <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span> &#125;;<br><br><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(nums)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(n);<br><br><span class="hljs-keyword">int</span> nums_copy[n] = &#123;&#125;;<br><br><span class="hljs-built_in">memcpy</span>(nums_copy, nums,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(nums));<br><br><span class="hljs-keyword">int</span> max_data = nums[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<br><br>&#123;<br><br>nums[i] += nums[i - <span class="hljs-number">1</span>];<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//找到最大的和，与其值；</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br><br>&#123;<br><br><br><br><span class="hljs-keyword">if</span> (max_data &lt; nums[i])<br><br>&#123;<br><br>max_data = nums[i];<br><br>k = i;<br><br>&#125;<br><br>&#125;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k;; i--)<br><br>&#123;<br><br><span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>)<br><br>&#123;<br><br>t = i;<br><br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><br>&#125;<br><br>cout &lt;&lt; max_data &lt;&lt; endl;<br><br><span class="hljs-comment">//输出最大和的子序列</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t + <span class="hljs-number">1</span>; i &lt;= k; i++)<br><br>cout &lt;&lt; nums_copy[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开课吧3天玩转数据分析</title>
    <link href="/2021/06/19/%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2021/06/19/%E5%BC%80%E8%AF%BE%E5%90%A73%E5%A4%A9%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="python与数据分析基础工具"><a href="#python与数据分析基础工具" class="headerlink" title="python与数据分析基础工具"></a>python与数据分析基础工具</h2><p>如何利用数据驱动业务？？？<br>数字化转型</p><p>数据分析职业发展</p><p>数据工程师-&gt;数据分析师-&gt;数据挖掘工程师-&gt;数据科学家</p><h3 id="python-语言基础操作"><a href="#python-语言基础操作" class="headerlink" title="python 语言基础操作"></a>python 语言基础操作</h3><h3 id="1-1数据结构"><a href="#1-1数据结构" class="headerlink" title="1.1数据结构"></a>1.1数据结构</h3><p>常见的python数据结构包括：元组、列表、字典、集合</p><h4 id="1-1-1元组"><a href="#1-1-1元组" class="headerlink" title="1.1.1元组"></a>1.1.1元组</h4><p>元组是一个固定长度，不可改变的python 序列对象。创建元组最简单的方式，用逗号分隔一列值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">tup</span>=4,5,6<br><span class="hljs-builtin-name">print</span>(tup)<br>(4,5,6)<br></code></pre></td></tr></table></figure><p>嵌套复杂的元组：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">nested_tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(nested_tup)</span></span><br><span class="hljs-function"><span class="hljs-params">((<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span>, <span class="hljs-params">(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span>)</span><br></code></pre></td></tr></table></figure><p>可以使用tuple命令，将其他数据结构直接转化为元组</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tuple</span><span class="hljs-params">([<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])</span></span><br>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>将字符串转为元组</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">tur=tuple(&#x27;string&#x27;)<br>print(<span class="hljs-name">tur</span>)<br>(&#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;)<br></code></pre></td></tr></table></figure><p>元组一旦创建，元组中的对象就不能修改了</p><p>元组添加元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=tuple(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;foo&#x27;</span>,[1,2]</span>,True])<br>tup<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.append</span>(<span class="hljs-number">3</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(tup)</span></span><br>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-selector-attr">[1, 2, 3]</span>, True)<br></code></pre></td></tr></table></figure><p>如果将元祖赋值给类似元组的变量，python会尝试拆分等号右边的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tup=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>,c=tup<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>tuple（元组）的应用场景主要有三个：、</p><ol><li>函数的参数和返回值，一个函数可以接收任意多个参数，一次返回多个数据</li><li>格式字符串</li><li>让列表不可以被修改，保护数据</li></ol><h4 id="1-1-2列表"><a href="#1-1-2列表" class="headerlink" title="1.1.2列表"></a>1.1.2列表</h4>]]></content>
    
    
    <categories>
      
      <category>pyhton</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyhton数据结构</tag>
      
      <tag>numpy</tag>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>念</title>
    <link href="/2021/06/17/%E5%BF%B5/"/>
    <url>/2021/06/17/%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="淮南先生与洛枳小姐"><a href="#淮南先生与洛枳小姐" class="headerlink" title="淮南先生与洛枳小姐"></a>淮南先生与洛枳小姐</h2><p>本来想写博客是想着记录研究生的学习之路，但最近似乎没有什么技术学习进展,就先写写我的淮南与洛枳的故事吧~</p><p>最近淮南先生在出差，来找洛枳小姐的计划泡汤了。洛枳小姐企盼许久见面就这么推迟了，毕竟他们已经有两个月的时间没有见面了。她非常生气，也觉得对这段从一开始就异地，到现在为止2年3个月的感情坚持不下去了，于是给淮南先生写了很长很长的一段话。大致意思就是感觉自己不能很好的理解他，希望有一个能在身边陪伴的人。自从淮南先生有了工资后，每天都会给洛枳小姐发红包。一开始是0.01元，洛枳小姐说这象征着他们每天都会再深爱一分。今年春节后，淮南先生给洛枳小姐涨工资了，每天0.52元。</p><p>那天早晨淮南先生依旧给洛枳小姐发了红包，却一句话都没有说。洛枳小姐猜想淮南先生肯定对她很失望，两个人或许就这样了吧，最美好的爱情可能就这样结束了吧。于是，一整天的时间浑浑噩噩，脑海中不断浮现遇见淮南先生的点点滴滴……</p><p>不知怎么，洛枳小姐回想初见淮南先生的画面，顿了一下，才想起那个片段。记不清具体时间了，也忘记了是哪个季节，春、夏初或是秋，只记得是阳光明媚的下午，阳光打在淮南先生的身上，整个人熠熠发光。正是高中生感情懵懂的时候，小女生在那一刻心里就烙下了眼前会发光的男孩~很久之后，洛枳小姐才知晓了男孩的姓名。慢慢地，在写作业的时候碰到男孩名字中的字都会觉得异常亲切，又悄悄的在本子上重复画着那个字；</p><p>日记中开始出现一个男生，昨天遇见他了，今天他穿的蓝色的衣服，明天他有体育课，下周一升国旗的播报会听见他的声音，最近一次的月考他又上榜了,突然感觉他有的时候很孤单，他似乎和好朋友又吵架了……似乎所有他的琐事她都知晓。</p><p>高中两年多的时间，洛枳小姐还是没有让淮南先生知道她的存在，她也不知道原因，可能是自己不是学霸，也并不是校园里漂亮的女孩就只是普通得不能再普通的学生，她啊，也只是众多关注淮南先生的女孩们中的一个微不足道的角色，总之，最后男孩不知道女孩的名字。</p><p>高考成绩出来了，女孩和家里边商量决定复读了。回到高中，熟悉的场景，但是好像找不到曾经熟悉的那个身影了，回想到这，现在思念的感觉似曾相识。几个月之后，女孩淘到了男孩的qq。就像得到了世界上最好的宝贝，满心期待、小心翼翼地在验证消息里输入‘一中校友’，等待男孩的验证通过。是的，那一刻感觉要飞起来，女孩也不知道说什么，但有了好友的关系总是让她兴奋的，因为他们之间总算有了点关系的。那段时间，聊的最多的就是放月假时的三五句话，但洛枳小姐都会收藏、截图保存、放进云盘中。</p><p>2016年8月26日，是淮南先生与洛枳小姐的第一次见面，他们约定在高中校门口。洛枳小姐清晰的记得，那天早上下着雨，是坐亲戚车到的校门口，雨淅淅沥沥的，下得不大不小。洛枳小姐买了一把蓝色的伞，撑着伞在学校门口边走边张望，过来许久，依旧没有淮南先生的消息，准备打道回府。犹豫着是否还继续等待，终于收到了他发过来的消息。他们走了很多路，似乎谈论得并不多，但很舒服，中午吃的米粉。雨过天晴，阳光刺眼灼人，他们在一个凉亭中歇下来……</p><p>2017年2月14日，是淮南先生与洛枳小姐的第二次见面。正月里总要和家人、同学聚聚，日子一天一天推，就巧合地到了情人节尴尬的日子。半年的时间，洛枳小姐曾有了一个男朋友，淮南先生也谈了一次恋爱，最后都分开了，洛枳小姐知道，她是无法放下烙在心里的男孩。中午依旧吃的米粉，然后淮南先生在车站送洛枳回家。</p><p>2017年4月22日，是淮南先生与洛枳小姐的第三次见面。这一天是洛枳小姐的生日，是她有了很久的愿望，希望淮南先生能陪她过一次生日，哪怕就一次。她前一天晚上坐火车，凌晨两点到达北京，淮南先生在车站等她，他们那个晚上都没有睡觉，四点多跑着去天安门看升旗，白天去了故宫、淮南先生的学校……通宵致使的迷迷糊糊，但和淮南先生在一起，那种感觉还是很美好。</p><p>2017年4月26日，淮南先生与洛枳小姐在一起了。<br><img src="/2021/06/17/%E5%BF%B5/nian.jpg"><br>…… ……<br>两人之间已经能接受距离、时间的考验，早已离不开彼此，这点小困难似乎不值一提。其实洛枳小姐在发出长长消息的那一刻就想撤回，但还是任性地想看看淮南先生的反应。</p><p>刚刚淮南先生发语音说，给洛枳小姐准备了礼物（听声音有幸福的味道），由快递小哥送过来，等待礼物中~<br>（ps:背景图是第三次见面，淮南先生拍的，影子里的两个人像不像在牵手~）</p>]]></content>
    
    
    <categories>
      
      <category>淮南洛枳</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/17/hello-world/"/>
    <url>/2021/06/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
